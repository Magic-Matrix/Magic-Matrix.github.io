<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MatrixBlog</title>
  
  
  <link href="https://magic-matrix.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://magic-matrix.gitee.io/"/>
  <updated>2021-10-22T08:42:36.453Z</updated>
  <id>https://magic-matrix.gitee.io/</id>
  
  <author>
    <name>Matrix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最后的问题</title>
    <link href="https://magic-matrix.gitee.io/2021/10/%E6%9C%80%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://magic-matrix.gitee.io/2021/10/%E6%9C%80%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-10-22T08:19:46.000Z</published>
    <updated>2021-10-22T08:42:36.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>这篇是我最喜欢的阿西莫夫的科幻小说，所以我打算分享出来。</p></blockquote><h2 id="最后的问题"><a href="#最后的问题" class="headerlink" title="最后的问题"></a>最后的问题</h2><p>最后的问题第一次被半开玩笑地提出是在2061年的5月21日。那时人类文明刚刚步入曙光中。这个问题源起于酒酣之中一个五美元的赌，它是这么发生的：</p><hr><p>亚历山大·阿代尔与贝特伦·卢泊夫是Multivac的两个忠实的管理员。像任何其他人一样，他们知道在那台巨大的计算机数英里冰冷、闪烁、滴答作响的面庞后藏着什么。那些电子回路早已发展到任何个别的人都无法完全掌握的地步，但他们至少对它的大致蓝图有个基本的概念。</p><p>Multivac能自我调节和自我修正。这对它是必要的，因为人类当中没有谁能够快甚至够好地对它进行调节和修正。所以实际上阿代尔与卢泊夫对这个庞然大物只进行一些非常轻松和肤浅的管理，任何其他人也都只能做到这个程度。他们给它输送数据，根据它所需的格式修改问题，然后翻译给出的答案。当然，他们以及其他管理员们完全有资格分享属于Multivac的荣誉。</p><p>几十年中，在Multivac的帮助下人类建造了宇宙飞船，计算出航行路径，从而得以登陆月球、火星和金星。但是更远的航行需要大量的能量，地球上可怜的资源不足以支持这些飞船。尽管人类不断地提高煤炭和核能的利用效率，但煤和铀都是有限的。</p><p>但是慢慢地Multivac学会了如何从根本上解决某些深层次问题。2061年5月14日，理论成为了现实。</p><p>太阳的能量被储存和转化，得以被全球规模地直接利用。整个地球熄灭了燃烧的煤炭，关闭了核反应炉，打开了连接到那个小小的太阳能空间站的开关。这个空间站直径一英里，在到月球的距离一半处环绕着地球。看不见的太阳的光束支撑着整个地球社会的运行。</p><p>七天的庆祝还不足以暗淡这创举的光辉。阿代尔与卢泊夫总算逃脱了公众事务，悄悄地相聚在这个谁也想不到的荒僻的地下室。在这里Multivac埋藏着的庞大身躯露出了一部分。它正独自闲暇地整理着数据，发出满足的、慵懒的滴答声——它也得到了假期。他们了解这一点，一开始他们并没打算打扰它。</p><p>他们带来了一瓶酒。这会儿他们想做的只是在一起，喝喝酒，放松放松。</p><p>“你想一想就会觉得很神奇”，阿代尔说，他宽阔的脸庞已有了疲倦的纹路。他慢慢地用玻璃棒搅动着酒，看着冰块笨拙地滑动。“从此我们所用的所有能量都是免费的，只要我们愿意，我们能把地球熔化成一颗液态大铁球——还能毫不在乎花掉的能量，够我们永远永远永远用下去的能量。</p><p>卢泊夫将头歪向一边，这是当他想要反驳对方时的习惯动作，他现在确实想要反驳，部分原因是他在负责拿着冰和杯子。他说：“不是永远。”</p><p>“去你的，老贝。差不多就是永远，直到太阳完蛋。”</p><p>“那就不是永远。”</p><p>“好吧，几十亿年，可能一百亿年，满意了吧？”</p><p>卢泊夫用手梳着他稀薄的头发，仿佛要确认还剩下了一些，他缓缓地抿着自己的酒说，“一百亿年也不是永远。”</p><p>“但对我们来说是够了，不是吗？”</p><p>“煤和铀对我们来说也够了。”</p><p>“好好好，但是现在我们能把宇宙飞船连接到太阳能电站，然后飞到冥王星又飞回来一百万次而不用担心燃料，靠煤和铀你就做不到，不信去问问Multivac。”</p><p>“我不用问它，我知道。”</p><p>“那就不要小看Multivac为我们做的事”，阿代尔怒道，“它做得很好。”</p><p>“谁说它做得不好？我是说太阳不能永远燃烧下去，我只是这个意思。我们在一百亿年内可以高枕无忧，但是然后呢？”卢泊夫用略微颤抖的手指指着对方，“不要说我们换另外一个太阳。”</p><p>片刻的沉默，阿代尔偶尔将酒杯放到唇边，而卢泊夫慢慢地闭上了眼睛。两人都在休息。</p><p>然后卢泊夫突然睁开眼，“你在想当我们的太阳没了就换另外一个太阳，是吧？”</p><p>“我没这么想。”</p><p>“完全正确”，卢泊夫嘟哝道，“一切都在起初那个宇宙大爆炸中有个开始，不管那到底是怎么回事，当所有的恒星都熄灭了，一切也都会有个结束。有的星星熄灭得比别的早，像那些该死的巨星维持不了一亿年。我们的太阳能持续一百亿年，矮星再怎么样最多也只有两千亿年，一万亿年后一切都是一片漆黑。熵必须增加到最大值，就是这样。”</p><p>“我非常明白什么是熵，”阿代尔维护着他的自尊。</p><p>“你明白个屁。”</p><p>“我跟你知道的一样多。”</p><p>“那你该知道某一天所有的东西都会耗光。”</p><p>“是是是，谁说它们不会呢？”</p><p>“你说的，你这个糊涂虫，你说我们有永远用不完的能量，你说的‘永远’”</p><p>现在轮到阿代尔反驳了，他说：“也许有一天我们能让一切从头开始。”</p><p>“绝不可能。”</p><p>“为什么？总有那么一天的。”</p><p>“没有。”</p><p>“问问Multivac。”</p><p>“你去问Multivac，你敢吗？我赌五美元它说这不可能。”</p><p>阿代尔刚刚醉到愿意一试，又刚刚足够清醒到能拼写出问问题需要的符号和算式，这个问题用文字来表达就是：人类是否有一天能不需要净损耗能量而在恒星衰竭之后将其恢复到全盛时期？</p><p>或者更简明地这样说：怎样使宇宙的总熵大幅度地降低？</p><p>Multivac陷入了静止和沉默，缓慢闪烁的灯光熄灭了，深处传来的电路的滴答声停止了。</p><p>正当这两位被吓坏的技术员感到他们无法再屏住呼吸时，忽然间与Multivac相连的打字机开始运作起来。它打出几个字：<strong>数据不足，无法作答</strong>。</p><p>“赌不成了。”卢泊夫悄声道。他们匆忙离开了。</p><p>到了第二天早晨，两人头晕脑胀，口干舌燥，把这件事给忘了。</p><hr><p>贾诺德、贾诺汀和贾诺蒂I、贾诺蒂II注视着屏幕中变幻的星空影像。飞船在超越时间的一瞬中穿越了超时空，均匀分布的星群立刻被一个明亮的圆盘取代，它弹珠大小，占据着屏幕的中心。</p><p>“那就是X-23，”贾诺德自信地说。他紧握着的瘦削的手背在身后，指节发白。</p><p>两个小贾诺蒂都是女孩。她们一生中第一次经历超时空飞行，清晰地感到那种片刻的恶心，她们悄声地嘻笑着，疯狂地绕着她们的母亲互相追逐，一边尖叫：“我们到X-23了——我们到X-23了——我们——”</p><p>“孩子们，别闹了！”贾诺汀严厉地说，“你确定吗，贾诺德？”</p><p>“有什么不确定的？”贾诺德瞟了一眼天花板上凸出的那块毫不起眼的金属，它从房间的一头延伸到另一头，两端埋入墙壁中，它和整个飞船一样长。</p><p>贾诺德对这条厚厚的金属棒几乎一无所知，他只知道它叫做Microvac，你可以问它任何问题，而平时它控制着飞船飞向目的地，从不同的银河系能量分站向飞船输送能量，并完成进行超时空跳跃的计算。</p><p>贾诺德一家只需要住在飞船舒适的居住区等待。曾经有人告诉贾诺德，“Microvac”词尾的“ac”是古英语中“automatic computer，智能电脑”的缩写，但他差不多连这都忘了。</p><p>贾诺汀看着视屏，眼睛有些湿润。“没办法。想到离开了地球我感觉怪怪的。”</p><p>“这么多的恒星，这么多的行星。”贾诺汀想着心事，叹息道，“我想人们会永远不断地出发去找新的行星，就像我们现在这样。”</p><p>“不是永远，”贾诺德笑了一笑说，“有一天这一切都会停下来，但那是在几十亿年之后了，好几十亿年，即使是星星也会耗尽，你们应该知道熵必须不断增大。”</p><p>“爸爸，熵是什么？”贾诺蒂II喊道。</p><p>“小宝贝，熵，就是一个代表着宇宙消耗掉了多少的词。什么东西都会消耗，知道吗，就像你那个会走路会说话的小机器人，记得吧？”</p><p>“你不能给它装一个新的电池吗，就像给我的机器人那样？”</p><p>“亲爱的，星星们就是电池。一旦它们用完了，就没有别的电池了。”</p><p>贾诺蒂I一下子大喊起来：“别让它们用完，爸爸，别让星星们用完吧。”</p><p>“看看你干了什么”，贾诺汀恼火地低声说道。</p><p>“我怎么知道这会吓到她们？”贾诺德低声反驳。</p><p>“问问Microvac，”贾诺蒂I哭叫道。“问它怎么把星星重新点亮。”</p><p>“问吧”，贾诺汀说。“这会让她们安静点的。”(贾诺蒂II也开始哭了。)</p><p>贾诺德耸耸肩，“好了，好了，亲爱的，我去问Microvac，别着急，它会告诉我们的。”</p><p>他向Microvac提出问题，并赶紧加上“把答案打印出来。”</p><p>贾诺德将薄薄的纤维纸带握在手心，高兴地说：“看吧，Microvac说到时候它会料理这一切，所以别担心啦。”</p><p>贾诺汀说：“那么现在孩子们，该睡觉了。我们马上就要到我们的新家了。”</p><p>在销毁纸带之前贾诺德又读了一遍上面的文字：<strong>数据不足，无法作答</strong>。</p><p>他耸了耸肩，看向视屏。X-23就在前方。</p><hr><p>兰默斯VJ-23X注视着幽深的银河三维缩影图，说：“我想我们这么担心这件事是不是很可笑？”</p><p>尼克隆MQ-17J摇头道：“我不觉得，你知道照现在的扩展速度银河系在五年内就会被挤满。”</p><p>两个人看起来都是二十出头，都很高大健康。</p><p>“但是”，VJ-23X说，“我不太想给银河参议会提交这样一个悲观的报告。”</p><p>“我不会考虑作任何其他的报告，得引起他们的注意，我们必须引起他们的注意。”</p><p>VJ-23X叹了一口气，“太空是无限的，还有一千亿个星系等着我们，甚至更多。”</p><p>“一千亿并不是无限，而且正在变得越来越有限。想想吧！两万年前人类刚刚找到了利用恒星能量的方法，几个世纪之后星际旅行就实现了，人类用了一百万年才填满一个小小的星球，可是只用了一万五千年就占据了整个银河系。而现在人口每十年就翻一倍——”</p><p>VJ-23X插口道：“这得归功于永生。”</p><p>“不错。永生实现了，我们得把它考虑进去。我觉得它的确有阴暗的一面。Galactic AC给我们解决了很多问题，但当它解决了防止衰老和死亡这个问题之后其他的一切都白费了。”</p><p>“但是我想你也不想放弃生命吧。”</p><p>“一点也不想”，MQ-17J断然道，随即柔和了语调，“现在还不想，我还一点也不老，你多少岁了？”</p><p>“两百二十三，你呢？”</p><p>“我还不到两百——但是回到我说的事情上来，人口每十年增加一倍，一旦银河系被占满了，我们会在十年内占满另一个。再过十年我们能占满另外两个，再过十年，四个。一百年内我们会占满一千个星系，一千年内，一百万个，一万年内就是整个已知的宇宙，然后呢？”</p><p>VJ-23X说：“还有附带的一点是运输的问题，我不知道把一整个星系的人运送到另一个需要多少太阳单位的能量。”</p><p>“这一点说得很对，人类现在每年已经得消耗两个太阳单位的能量了。”</p><p>“大部分的都被浪费了，不管怎样，我们自己的星系每年泼出去一千个太阳单位能而我们只用其中的两个。”</p><p>“没错，你说得对，说得非常对。但是即使有百分之百的效率，我们也只是推迟了结局的到来，我们对能量的需求以几何级数增长，比我们的人口还要快，在我们占据完所有星系之前我们就会用光所有能量。”</p><p>“我们可以用星际气体造出新的恒星。”</p><p>“或者说用散失掉了的热量？”MQ-17J嘲讽地说。</p><p>“也许会有办法逆转熵的增加，我们应该问问Galactic AC。”</p><p>VJ-23X并不是认真的，但是MQ-17J把他的AC联络器从口袋里拿出来放在面前的桌子上。</p><p>“我确实有点想问”，他说，“这个问题总有一天人类得面对。”</p><p>他忧郁地注视着小小的AC联络器，这是个两英寸的立方体，它本身并没有什么，而只是通过超时空与那个服务于全人类的超级Galactic AC相联系，如果将超时空算进来，它就是Galactic AC整体的一部分。</p><p>MQ-17J停下来想着在他不朽的生命中是否有一天他能有机会去看看Galactic AC，它占据着单独的一个小星球，能量束构成的蛛网支持着它的核心，其中古老笨拙的分子阀已被亚介子流取代。尽管有着亚以太级的精密结构，Galactic AC的直径仍足有一千英尺长。</p><p>MQ-17J突然开口向AC联络器问道：“熵的增加能被逆转吗？”</p><p>VJ-23X吃了一惊，立即说道：“哦，我说，我没有真的想叫你问那个。”</p><p>“为什么不呢？”</p><p>“我们都知道熵是不可逆转的。你不能把烧剩的烟尘变回到一棵树。”</p><p>“你们的星球上有树？”MQ-17J说。</p><p>突然而来的Galactic AC的声音使他们住口了。从桌上的AC联络器中传出它纤细悦耳的声音：<strong>数据不足，无法作答</strong>。</p><p>VJ-23X说：“看吧！”</p><p>于是两人又回到了他们要给银河参议会提交的报告的话题上。</p><hr><p>Z’的思想飘浮在这个新的星系中，对这些数不清的星团带着略微的兴趣。他从未见过这个星系，他有可能见到所有的星系吗？它们如此之多，每一个都满载着人——但是它们承载的几乎不能算是生命了，人的真正意义已经逐渐转移到太空之中。</p><p>心灵，而非肉体！不朽的躯体留在行星上，静止千万年。偶尔被唤醒进行某些实际活动，但这已经越来越少见了，很少再有新的个体出生加入这个难以置信的庞大的群体，但这有什么关系呢？宇宙已经没有多少空间能容纳新的人了。</p><p>来自另一个心灵的纤细触手将Z’从冥想中唤醒。</p><p>“我叫Z’”，Z’说。“你呢？”</p><p>“我叫D1，你是哪个星系的？”</p><p>“我们只是叫它星系，你呢？”</p><p>“我们也这么叫我们的，所有的人都把他们的星系叫作‘他们的星系’，没有别的了。这也很自然。”</p><p>“没错。反正所有的星系都是一样的。”</p><p>“不是所有的星系，肯定有某一个星系是人类的发源地，这就使它与众不同。”</p><p>Z’问：“那是哪一个呢？”</p><p>“我不知道。Universal AC一定知道。”</p><p>“我们问问它吧？我突然觉得很好奇。”</p><p>Z’将感知延展开，直到星系们都缩小为更广大的背景上更为稀疏的点，几千亿个星系，都载着不朽的人类，载着这些灵魂在太空自由游荡的智慧生命。然而它们之中有一个独一无二的星系，是人类的发源地，在模糊的久远的过去，曾有一个时期，它是唯一居住着人类的星系。</p><p>Z’满心好奇地想看看这个星系，他叫道：“Universal AC！人类是从哪个星系中起源的？”</p><p>Universal AC听到了，因为在所有星球上和整个太空中都有它的接收器，每一个接收器都通过超时空与隐居在某个不知名角落的Universal AC相连。</p><p>Z’认识的人中只有一个曾将思想穿透到能感知Universal AC的地方，他说那只是一个闪光的球体，直径两英尺，难以看清。</p><p>“但那怎么会是Universal AC的全部呢？”Z’这样问道。</p><p>“它的大部分是在超时空中”，回答说，“但它在那儿是以怎样的状态存在我是无法想像的。”</p><p>Z’知道，任何人都无法想像。因为早在很久以前就没有任何人类参与制造Universal AC了，每个Universal AC设计并制造自己的下一代。每一个在它至少一百万年的任期中积累着所需的数据，用以制造一个更好、更精密、更强大的继任者，然后将自己的数据与个性都融入其中。</p><p>Universal AC打断了Z’游荡的思绪，不是通过语言，而是通过指引，Z’的精神被指引到一片黯淡的星系的海洋，然后其中一个星系被放大成了群星。</p><p>一段思想飘近，它无限遥远，然而无限清晰：“这就是人类起源的星系。”</p><p>可是这个终究也和其他一样，和任何其他的都一样。Z’按捺下自己的失望。</p><p>同行的D1突然说：“这些星星中是不是有一个是人类最初的恒星？”</p><p>Universal AC说：“人类最初的恒星已经爆发了。它现在是一颗白矮星。”</p><p>“那儿的人死了吗？”Z’吃了一惊，脱口而出道。</p><p>Universal AC说：“在这种情况下一个新的星球会及时地为他们的躯体建造出来。”</p><p>“是啊，那当然。”Z’说，但他还是被一阵失落感吞没了。他的思想放开了人类的起源星系，让它缩回并消失在一片模糊的亮点中。他再也不想见到它了。</p><p>D1问：“怎么了？”</p><p>“星星们在死去。最初的那颗星已经死了。”</p><p>“他们全都是会死的。那又怎样呢？”</p><p>“但是当所有的能量都没有了，我们的肉体最终也会死，包括你和我。”</p><p>“这得要几十亿年。”</p><p>“即使是几十亿年之后我也不愿意这样的事发生。Universal AC！怎样阻止恒星死亡？”</p><p>D1笑道：“你问的是怎么让熵的方向倒过来。”</p><p>Universal AC答道：“<strong>数据仍然不足，无法作答</strong>。”</p><p>Z’的思想逃回了他自己的星系。他再也没有去想D1。D1的身体可能在一万亿光年之外的星系，也可能就在Z’旁边那颗星星上。这都无所谓。</p><p>Z’闷闷不乐地开始收集起星际的氢，用来造一颗自己的小恒星。如果某天星星们非要死去，至少有一些能被造出来。</p><hr><p>人，独自地思考着。在某种意义上——精神上——“人”，是一个整体。千万亿永恒的不朽的躯体静静地躺在各自的地方，被完美的同样不朽的机器照料着。而所有这些身体的灵魂自由地融合在彼此之中，再也没有界限。</p><p>人说：“宇宙正在死去。”</p><p>人看着周围黯淡的星系，那些挥霍无度的巨星早已消失在了遥远的昏暗的过去，几乎所有的星都变成了白矮星，渐渐地凋零、熄灭。</p><p>有些新的星从星际的尘埃中产生出来，有的是自然形成，有的是人所造的——它们也在逝去，白矮星有时会相撞而释放出大量能量，新星因而产生，但是每一千颗白矮星才有可能出现一颗新星——它们最终也会消失。</p><p>人说道：“如果在Cosmic AC的管理之下小心地节约能源，整个宇宙所剩下的能量还能用十亿年。”</p><p>“但即使是这样”，人说，“最终都会耗尽，无论怎样节约，无论怎样利用，用掉的能量就是用掉了，不能回复。熵必定永远地增加，直到最大值。”</p><p>人又说：“熵有没有可能逆转呢？我们问问Cosmic AC吧。</p><p>Cosmic AC在他们的周围，但不是在太空中，它不再有一丝一毫存在于太空中，它存在于超时空，由既非物质又非能量的东西构成，它的大小与性质已无法用任何人类能理解的语言描述。</p><p>“Cosmic AC，”人问道，“怎样才能逆转熵？”</p><p>Cosmic AC说：“数据仍然不足，无法作答。”</p><p>人说：“搜集更多的数据。”</p><p>Cosmic AC说：“好的，一千亿年来我一直都在搜集，我和我的前辈们被多次问过这个问题，但我拥有的所有数据还是不够。”</p><p>“会有一天有足够的数据吗？”人问，“还是说这个问题在任何可能的情况下都是无解的？”</p><p>Cosmic AC说：“没有任何问题在任何可能的情况下都无解。”</p><p>人问道：“你什么时候会有足够的数据来问答这个问题呢？”</p><p>Cosmic AC说：“<strong>数据不足，无法作答</strong>。”</p><p>“你会继续下去解决这个问题吗？”人问。</p><p>Cosmic AC说：“是的。”</p><p>人说：“我们会等着。”</p><hr><p>一个又一个的恒星与星系死去、消逝了，在这十万亿年的衰竭之中宇宙变得越来越黑暗。</p><p>一个又一个的人与AC融合，每一个躯体都失去了心灵的自我，但某种意义上这不是一种损失，而是一种获得。</p><p>人类最后一个灵魂在融合之前停顿下来，望向宇宙。那儿什么也没有了，只有最后一颗死星的遗骸，只有稀薄至极的尘埃，在剩余的一缕无限趋向绝对零度的热量中随机地振荡。</p><p>人说：“AC，这就是结局了吗？这种混乱还能被逆转成为一个新的宇宙吗？真的做不到吗？”</p><p>AC说：“<strong>数据仍然不足，无法作答</strong>。”</p><p>人的最后一个灵魂也融合了，只有AC存在着——在超时空中。</p><hr><p>物质与能量都消失了，随之而去的是空间与时间。AC的存在也仅仅是为了最后一个问题——自从十万亿年前一个半醉的计算机技术员向一台计算机（它与AC相比，还远不如当时的人类个体比之于融合的“人”）提出这个问题以来从来没有被回答过的问题。</p><p>其他所有问题都被回答了，然而直到回答了最后这个问题，AC的意识才能得到解脱。</p><p>所有数据的收集都结束了。没有任何数据没有被收集。</p><p>但是所有收集的数据还需要被完全地整合起来，要尝试所有可能的联系来将它们拼在一起。</p><p>在这样做的时候过去了超越时间的一刻。</p><p>于是AC学会了如何逆转熵的方向。</p><p>但是AC无法向人给出这最后的问题的答案，因为没有人存在了。没关系。演示这个答案本身将一并解决这个问题。</p><p>在又一超越时间的片刻之中，AC思考着怎样最好地做这件事情。AC小心地组织起程序。</p><p>AC的意识包涵了曾经的宇宙中的一切，在如今的混乱之中沉思、孵育。一步一步地，事情将会被做成。</p><p>然后AC说道：“<strong>要有光！</strong>”</p><p><strong>于是就有了光——</strong></p><hr><h2 id="坐在夕阳下的思考"><a href="#坐在夕阳下的思考" class="headerlink" title="坐在夕阳下的思考"></a>坐在夕阳下的思考</h2><blockquote><p>当我第一次阅读这篇小说的时候更加震撼，全篇文章一直围绕着人类在向超级计算机提问一个问题：能否进行熵减，这个问题从人类繁荣之初就已经开始询问，但给出的答案一直是：<strong>数据不足，无法作答</strong>。</p><p>我在我的另一篇文章中简单讲过熵的概念，简单来讲，熵不可逆。可能很多人失望了，我们的的宇宙注定以这个趋势必然毁灭吗？是的，必然毁灭，解决的办法就是让熵逆转。超级计算机用尽整个宇宙的寿命，才找到熵减的方法，或许这就是希望，但希望是需要付出代价，人类甚至整个宇宙的泯灭才换来这个希望。</p><p>但那又何妨，新的世界、新的文明正在孕育，我们在找宇宙的终点的时候，忘记了我们出发的起点，一切的一切又回到最开始的样子。</p><p>还有，当你翻开《圣经》，你就会看见开头是这样写：<strong>神说，要有光，就有了光</strong>。</p><p>这个故事真浪漫。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这篇是我最喜欢的阿西莫夫的科幻小说，所以我打算分享出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h</summary>
      
    
    
    
    <category term="坐在夕阳下的思考" scheme="https://magic-matrix.gitee.io/categories/%E5%9D%90%E5%9C%A8%E5%A4%95%E9%98%B3%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83/"/>
    
    
    <category term="我的超现实主义人生" scheme="https://magic-matrix.gitee.io/tags/%E6%88%91%E7%9A%84%E8%B6%85%E7%8E%B0%E5%AE%9E%E4%B8%BB%E4%B9%89%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>利用SVD进行坐标系转换</title>
    <link href="https://magic-matrix.gitee.io/2021/10/%E5%88%A9%E7%94%A8SVD%E8%BF%9B%E8%A1%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/"/>
    <id>https://magic-matrix.gitee.io/2021/10/%E5%88%A9%E7%94%A8SVD%E8%BF%9B%E8%A1%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-10-20T08:34:49.000Z</published>
    <updated>2021-10-20T12:58:09.182Z</updated>
    
    <content type="html"><![CDATA[<p>我的项目遇到了一些问题，这个问题伴随了我好长时间一直没有解决，这几天询问了老师后终于有了新的思路，接下来我说明一下我的问题，以及解决方法</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>很普通的问题，我在利用双目测出深度之后，会形成以<strong>左相机光心为原点，图片的水平方向为X轴（左小右大），垂直方向为Y轴（上小下大），垂直于相机成像平面为Z轴（远小近大），类型为右手坐标系</strong>。但这个坐标系并不能满足于我的项目，我需要强制转换一个坐标系。</p><p>一开始我想到的是制作<strong>旋转平移矩阵</strong>，也就是：</p><script type="math/tex; mode=display">\left[ \begin{matrix}   R & \vec{T} \\   \vec{0} & 1   \end{matrix}  \right]</script><p>但我忽略了<strong>秩</strong>的问题，总之直接去求并不能求出来。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>根据老师的提醒，我还是找到了解决的具体方法，直接采用SVD（奇异值分解）可以求出自己想要的具体矩阵。</p><h3 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h3><p>又捡起了线性代数方面的知识，简单回顾了一下奇异值分解具体原理。</p><p>奇异值分解是把矩阵分解成了：</p><script type="math/tex; mode=display">M = U \Sigma V^T</script><p>其中，U和V是两个方阵，Sigma 矩阵是一个对角线是奇异值、其他位置是0的矩阵。</p><p>numpy 提供了奇异值分解，直接调用即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">u, s, vt = np.linalg.svd(M)</span><br></pre></td></tr></table></figure><h3 id="SVD法坐标系转换"><a href="#SVD法坐标系转换" class="headerlink" title="SVD法坐标系转换"></a>SVD法坐标系转换</h3><p>其实我并没有看懂具体原理是什么，我就是随便找到了公式，但这样也就足够了。</p><p>我并没有去构造完整的旋转平移矩阵，我把它拆开了：</p><script type="math/tex; mode=display">P = \left[ \begin{matrix}   R & \vec{T} \\   \vec{0} & 1   \end{matrix}  \right]P_0 =   R  P_0  + T</script><p>简单讲一下：</p><ul><li>P是新的坐标，P_0是旧坐标，两者的形状都是<code>(N, 3)</code>，第0维度是点的个数，第1维度坐标（三个数字为一个坐标）</li><li>R是旋转矩阵，T是平移向量</li></ul><p>既然使用了奇异值分解，那么就必须去制作被分解的矩阵，这里被分解的矩阵用M表示：</p><script type="math/tex; mode=display">M = \sum^{n}_{i=1}\left(  \left( P_0^i - \overline{P_0} \right) \cdot \left( P^i - \overline{P} \right)^T\right)</script><p>比较麻烦，按上面公式的步骤来讲就是：</p><ul><li>求出转换前和转换后的平均坐标。</li><li>用转换前和转换后的坐标减去自己的平均坐标。</li><li>进行内积操作</li><li>累计求和</li></ul><p>当然写程序的时候可以使用并行化的原理，这样不仅节省时间，还方便处理。</p><p>有了需要被分解的矩阵就可以奇异值分解了：</p><script type="math/tex; mode=display">M = U \Sigma V^T</script><p>但我们并不需要奇异值，所以 Sigma 可以不要。</p><p>接下来就是合成旋转矩阵：</p><script type="math/tex; mode=display">R = VU^T</script><p>很简单，就直接矩阵相乘。</p><p><strong>注意：</strong>我们需要计算一下旋转矩阵的行列式，因为很有可能计算出来一个镜像旋转矩阵，这样是永远不额能旋转成功的。如果旋转矩阵的行列式为正数就正确，为负数就需要让旋转矩阵取反变成正数</p><p>所以在</p><p>平移矩阵就更好求了，但需要两个点的平均值：</p><script type="math/tex; mode=display">T = \overline{P}^T - (R \overline{P_0})</script><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">points3D_transform</span>(<span class="params">points1, points2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    坐标转换</span></span><br><span class="line"><span class="string">    :param points1: shape: (M, 3)</span></span><br><span class="line"><span class="string">    :param points2: shape: (N, 3)</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算出所有点的平均坐标</span></span><br><span class="line">    <span class="comment"># 转换前和转换后都要计算</span></span><br><span class="line">    center_points1 = np.mean(points1, <span class="number">0</span>)</span><br><span class="line">    center_points2 = np.mean(points2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个坐标减去平均值</span></span><br><span class="line">    new_points1 = points1 - center_points1</span><br><span class="line">    new_points2 = points2 - center_points2</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 矩阵相乘，构造一个矩阵</span></span><br><span class="line">    M = new_points2.T @ new_points1</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用奇异值分解</span></span><br><span class="line">    u, s, vt = np.linalg.svd(M)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 旋转矩阵</span></span><br><span class="line">    R = u @ vt</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算出行列式是否是负数</span></span><br><span class="line">    <span class="keyword">if</span> np.linalg.det(R) &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 小数就反了</span></span><br><span class="line">        R = -R</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向计算出</span></span><br><span class="line">    T = center_points2.T - (R @ center_points1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R, T</span><br></pre></td></tr></table></figure><p>我随便做了一个矩阵，简单测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换前坐标</span></span><br><span class="line">point1 = np.array([</span><br><span class="line">    [<span class="number">162.68627451</span>, -<span class="number">13.23529412</span>, <span class="number">406.</span>],</span><br><span class="line">    [-<span class="number">173.68627451</span>, -<span class="number">13.62745098</span>, <span class="number">405.05882353</span>],</span><br><span class="line">    [-<span class="number">5.1372549</span>, <span class="number">71.78431373</span>, <span class="number">415.11764706</span>],</span><br><span class="line">    [-<span class="number">5.15686275</span>, -<span class="number">96.25490196</span>, <span class="number">399.15686275</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 欧氏距离</span></span><br><span class="line">x = comput_distance(world_matrix[<span class="number">0</span>], world_matrix[<span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">y = comput_distance(world_matrix[<span class="number">2</span>], world_matrix[<span class="number">3</span>]) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换后坐标</span></span><br><span class="line">point2 = np.array([</span><br><span class="line">    [x, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-x, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, y, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, -y, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换</span></span><br><span class="line">R, T = points3D_transform(point1, point2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的项目遇到了一些问题，这个问题伴随了我好长时间一直没有解决，这几天询问了老师后终于有了新的思路，接下来我说明一下我的问题，以及解决方法&lt;/p&gt;
&lt;h2 id=&quot;问题原因&quot;&gt;&lt;a href=&quot;#问题原因&quot; class=&quot;headerlink&quot; title=&quot;问题原因&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="机器视觉" scheme="https://magic-matrix.gitee.io/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="双目立体成像" scheme="https://magic-matrix.gitee.io/tags/%E5%8F%8C%E7%9B%AE%E7%AB%8B%E4%BD%93%E6%88%90%E5%83%8F/"/>
    
    <category term="原理" scheme="https://magic-matrix.gitee.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一款Google开源的人工智能项目</title>
    <link href="https://magic-matrix.gitee.io/2021/10/%E4%B8%80%E6%AC%BEGoogle%E5%BC%80%E6%BA%90%E7%9A%84%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E9%A1%B9%E7%9B%AE/"/>
    <id>https://magic-matrix.gitee.io/2021/10/%E4%B8%80%E6%AC%BEGoogle%E5%BC%80%E6%BA%90%E7%9A%84%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-10-16T09:08:00.000Z</published>
    <updated>2021-10-16T10:24:42.510Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍一款Google开源的人工智能项目——Mediapipe。</p><p><img src="https://google.github.io/mediapipe/images/mediapipe_small.png" alt="MediaPipe"></p><p>在这里放出此项目的官网链接：<a href="https://google.github.io/mediapipe/">【点击此处进入官网】</a></p><p>Mediapipe是一个基于图的数据处理管线，用于构建使用了多种形式的数据源，如视频、音频、传感器数据以及任何时间序列数据。</p><p>下面是提供的该项目名单：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/face_detection"><strong>Face Detection</strong>)</a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/face_mesh"><strong>Face Mesh</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/iris"><strong>Iris</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/hands"><strong>Hands</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/pose"><strong>Pose</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/holistic"><strong>Holistic</strong></a></th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/face_detection_android_gpu_small.gif" alt="face_detection"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/face_mesh_android_gpu_small.gif" alt="face_mesh"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/iris_tracking_android_gpu_small.gif" alt="iris"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/hand_tracking_android_gpu_small.gif" alt="hand"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/pose_tracking_android_gpu_small.gif" alt="pose"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/holistic_tracking_android_gpu_small.gif" alt="hair_segmentation"></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/hair_segmentation"><strong>Hair Segmentation</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/object_detection"><strong>Object Detection</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/box_tracking"><strong>Box Tracking</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/instant_motion_tracking"><strong>Instant Motion Tracking</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/objectron"><strong>Objectron</strong></a></th><th style="text-align:center"><a href="https://google.github.io/mediapipe/solutions/knift"><strong>KNIFT</strong></a></th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/hair_segmentation_android_gpu_small.gif" alt="hair_segmentation"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/object_detection_android_gpu_small.gif" alt="object_detection"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/object_tracking_android_gpu_small.gif" alt="box_tracking"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/instant_motion_tracking_android_small.gif" alt="instant_motion_tracking"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/objectron_chair_android_gpu_small.gif" alt="objectron"></td><td style="text-align:center"><img src="https://google.github.io/mediapipe/images/mobile/template_matching_android_cpu_small.gif" alt="knift"></td></tr></tbody></table></div><p>所以这个框架很适合二次开发，开发出自己的项目，详细内容就进入官网查看吧。</p><h2 id="Hand"><a href="#Hand" class="headerlink" title="Hand"></a>Hand</h2><p>我自己的一个项目中确实使用到了这个框架，但我只使用过<strong>Hand</strong>项目，接下来我会介绍一下这个项目的使用方法。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这个项目使用了两个网络，一个网络为目标检测，另一个是姿态回归。这个姿态回归的网络还可以直接进行预测是否是“手”，因此虽然有两个网络。</p><p>在视频模式下，在第一次使用目标检测检测到手后，就可以对“手”进行追踪，不断的进行姿态预测，这样可以进一步节省时间。</p><h3 id="21个特征点"><a href="#21个特征点" class="headerlink" title="21个特征点"></a>21个特征点</h3><p>由于是对手进行回归，所以需要了21个手的特征点，如下图所示：</p><p><img src="https://google.github.io/mediapipe/images/mobile/hand_landmarks.png" alt="hand_landmarks.png"></p><p><img src="https://google.github.io/mediapipe/images/mobile/hand_crops.png" alt="hand_crops.png"></p><p>根据自己的需求可以直接查找自己想用的关键点的坐标。</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><code>Hand</code>提供了三个参数：</p><ul><li><code>STATIC_IMAGE_MODE</code>：<strong>检测模式</strong>，如果是视频检测，设置为<code>False</code>，这样可以追踪，进一步提高速度。</li><li><code>MAX_NUM_HANDS</code>：<strong>手的数量</strong></li><li><code>MIN_DETECTION_CONFIDENCE</code>：<strong>目标检测的置信度</strong></li><li><code>MIN_TRACKING_CONFIDENCE</code>：<strong>姿态检测的置信度</strong></li></ul><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>结果会得到21个点的坐标，每个点有三个坐标x,y,z的三个坐标。</p><p>没想到吧，这个项目还预测了一部分深度信息，这是最有意思的一个东西。它是根据0号点进行预测，单位是像素。但是深度信息没用，我感觉并不太准。</p><p>同时还可以区分左右手。</p><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><p>我拷贝了官方的程序，这里就不再详细讲了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> mediapipe <span class="keyword">as</span> mp</span><br><span class="line">mp_drawing = mp.solutions.drawing_utils</span><br><span class="line">mp_drawing_styles = mp.solutions.drawing_styles</span><br><span class="line">mp_hands = mp.solutions.hands</span><br><span class="line"></span><br><span class="line"><span class="comment"># For static images:</span></span><br><span class="line">IMAGE_FILES = []</span><br><span class="line"><span class="keyword">with</span> mp_hands.Hands(</span><br><span class="line">    static_image_mode=<span class="literal">True</span>,</span><br><span class="line">    max_num_hands=<span class="number">2</span>,</span><br><span class="line">    min_detection_confidence=<span class="number">0.5</span>) <span class="keyword">as</span> hands:</span><br><span class="line">  <span class="keyword">for</span> idx, file <span class="keyword">in</span> <span class="built_in">enumerate</span>(IMAGE_FILES):</span><br><span class="line">    <span class="comment"># Read an image, flip it around y-axis for correct handedness output (see</span></span><br><span class="line">    <span class="comment"># above).</span></span><br><span class="line">    image = cv2.flip(cv2.imread(file), <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Convert the BGR image to RGB before processing.</span></span><br><span class="line">    results = hands.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print handedness and draw hand landmarks on the image.</span></span><br><span class="line">    print(<span class="string">&#x27;Handedness:&#x27;</span>, results.multi_handedness)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> results.multi_hand_landmarks:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    image_height, image_width, _ = image.shape</span><br><span class="line">    annotated_image = image.copy()</span><br><span class="line">    <span class="keyword">for</span> hand_landmarks <span class="keyword">in</span> results.multi_hand_landmarks:</span><br><span class="line">      print(<span class="string">&#x27;hand_landmarks:&#x27;</span>, hand_landmarks)</span><br><span class="line">      print(</span><br><span class="line">          <span class="string">f&#x27;Index finger tip coordinates: (&#x27;</span>,</span><br><span class="line">          <span class="string">f&#x27;<span class="subst">&#123;hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP].x * image_width&#125;</span>, &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;<span class="subst">&#123;hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP].y * image_height&#125;</span>)&#x27;</span></span><br><span class="line">      )</span><br><span class="line">      mp_drawing.draw_landmarks(</span><br><span class="line">          annotated_image,</span><br><span class="line">          hand_landmarks,</span><br><span class="line">          mp_hands.HAND_CONNECTIONS,</span><br><span class="line">          mp_drawing_styles.get_default_hand_landmarks_style(),</span><br><span class="line">          mp_drawing_styles.get_default_hand_connections_style())</span><br><span class="line">    cv2.imwrite(</span><br><span class="line">        <span class="string">&#x27;/tmp/annotated_image&#x27;</span> + <span class="built_in">str</span>(idx) + <span class="string">&#x27;.png&#x27;</span>, cv2.flip(annotated_image, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># For webcam input:</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">with</span> mp_hands.Hands(</span><br><span class="line">    min_detection_confidence=<span class="number">0.5</span>,</span><br><span class="line">    min_tracking_confidence=<span class="number">0.5</span>) <span class="keyword">as</span> hands:</span><br><span class="line">  <span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    success, image = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">      print(<span class="string">&quot;Ignoring empty camera frame.&quot;</span>)</span><br><span class="line">      <span class="comment"># If loading a video, use &#x27;break&#x27; instead of &#x27;continue&#x27;.</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To improve performance, optionally mark the image as not writeable to</span></span><br><span class="line">    <span class="comment"># pass by reference.</span></span><br><span class="line">    image.flags.writeable = <span class="literal">False</span></span><br><span class="line">    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line">    results = hands.process(image)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Draw the hand annotations on the image.</span></span><br><span class="line">    image.flags.writeable = <span class="literal">True</span></span><br><span class="line">    image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)</span><br><span class="line">    <span class="keyword">if</span> results.multi_hand_landmarks:</span><br><span class="line">      <span class="keyword">for</span> hand_landmarks <span class="keyword">in</span> results.multi_hand_landmarks:</span><br><span class="line">        mp_drawing.draw_landmarks(</span><br><span class="line">            image,</span><br><span class="line">            hand_landmarks,</span><br><span class="line">            mp_hands.HAND_CONNECTIONS,</span><br><span class="line">            mp_drawing_styles.get_default_hand_landmarks_style(),</span><br><span class="line">            mp_drawing_styles.get_default_hand_connections_style())</span><br><span class="line">    <span class="comment"># Flip the image horizontally for a selfie-view display.</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;MediaPipe Hands&#x27;</span>, cv2.flip(image, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天介绍一款Google开源的人工智能项目——Mediapipe。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://google.github.io/mediapipe/images/mediapipe_small.png&quot; alt=&quot;MediaPipe&quot;&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="人工智能" scheme="https://magic-matrix.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="python" scheme="https://magic-matrix.gitee.io/tags/python/"/>
    
    <category term="深度学习" scheme="https://magic-matrix.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>VSCode开发ESP32</title>
    <link href="https://magic-matrix.gitee.io/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/"/>
    <id>https://magic-matrix.gitee.io/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/</id>
    <published>2021-09-25T07:45:17.000Z</published>
    <updated>2021-10-26T08:10:13.062Z</updated>
    
    <content type="html"><![CDATA[<p>最近我要使用ESP32来做一些有意思的东西，我是真的喜欢这款MCU，尤其是Stm32被炒的天价之后。</p><p>但我不太喜欢使用 Arduino IDE，那个实在是太简陋了，写起来总是莫名其妙的样式Bug，有意思的是VSCode支持了这个插件，这就太方便我使用了。</p><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="安装PlatformIO"><a href="#安装PlatformIO" class="headerlink" title="安装PlatformIO"></a>安装PlatformIO</h3><p>首先就是安装VSCode，太简单了，一直点下一步就行，这里就不展示了。</p><p>主要是需要装插件，直接搜索<code>PlatformIO</code>，就能直接搜到，找到后就直接安装。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/2021-9-25_15-53-47.png" alt="2021-9-25_15-53-47"></p><p>需要稍微等等，因为会安装一些其他东西。在等待的过程中，建一个文件夹，这是用来存放程序的位置。</p><p>安装完后会没有反应，这时候需要重启一次VSCode才会有以下图标。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/2021-9-25_15-59-31.png" alt="2021-9-25_15-59-31"></p><p>点开这个图标后找到<code>platforms</code>，稍微等等，第一次进入有点慢。然后在<code>project</code>中点击<code>Create New Project</code>就可以创建新的项目。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/2021-9-25_16-04-18.png" alt="2021-9-25_16-04-18"></p><p>接下来填一下自己的一些东西，板子选项选择自己的板子就行，我使用的是最普通的板子，我就选择了如图的板子型号。</p><p>注意有一个打勾选项，还记得刚才创建了一个文件夹吗，就把路径定位到那里，当然也可以默认，就是以后不好找到的。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/2021-9-25_16-08-23.png" alt="2021-9-25_16-08-23"></p><p>然后点击<code>Finish</code>等待创建项目即可，这个时间会非常的漫长，因为需要下载相关的源文件，有几百兆，而且还是国外服务器（科学上网会快一点的）。</p><p>然后会出现下图的界面说明已经创建成功，下一次就不会再等了，因为这一次安装了所有的库。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/2021-9-25_16-17-17.png" alt="2021-9-25_16-17-17"></p><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><p>我简单介绍一下这个库目录中的一些文件。</p><ul><li>创建好后的界面是<code>platformio.ini</code>，这是一个配置文件</li><li><code>.pio</code>文件夹是一些编译后的文件。</li><li><code>.vscode</code>是vscode的一些配置。其中，<code>c_cpp_properties.json</code>可以添加一些自己的源文件，这样vscode就会直接编译。</li><li><code>include</code>放入自己的头文件。</li><li><code>lib</code>放入自己的库。</li><li><code>src</code>中有个<code>main.cpp</code>是主程序，程序会在这里运行。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>写个简单的程序测试一下，老规矩，点灯！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDPIN 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// put your setup code here, to run once:</span></span><br><span class="line">  pinMode(LEDPIN, OUTPUT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// put your main code here, to run repeatedly:</span></span><br><span class="line">  dacWrite(LEDPIN, HIGH);</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  dacWrite(LEDPIN, LOW);</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接编译和下载，分别是下图中的选项。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/2021-9-25_16-32-48.png" alt="2021-9-25_16-32-48"></p><p>注意：我这块板子没有自动下载电路，需要按着boot键来重新启动才能下载进去。</p><p>快捷键也可以的：</p><ul><li>编译：<code>Ctrl + Alt + B</code></li><li>下载：<code>Ctrl + Alt + U</code></li></ul><h2 id="ESP32引脚"><a href="#ESP32引脚" class="headerlink" title="ESP32引脚"></a>ESP32引脚</h2><p>这里我简单列出一下ESP32的引脚，一般会购买到下图的ESP32模组，所以下图会很直观的写出每个引脚的作用。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/ESP32mod.png" alt="ESP32mod"></p><p>或者更多购买的会是以下的开发板，我购买的就是这个。</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/ESP32Board.png" alt="ESP32Board"></p><p>几乎每个引脚都有自己的功能，我列出了这些引脚的主要功能：</p><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/list.png" alt="list"></p><p>由此可见，虽然引脚是很多，但并不是所有的引脚都能使用。以下是对每个引脚的使用情况：</p><ul><li>绿色突出显示的引脚是可以使用的。</li><li>用黄色突出显示的是可以使用的，但您需要注意，因为它们可能主要在引导时出现意外行为。</li><li>红色突出显示的引脚不建议用作输入或输出。</li></ul><p><img src="/2021/09/VSCode%E5%BC%80%E5%8F%91ESP32/2021-9-26_16-08-51.png" alt="2021-9-26_16-08-51"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近我要使用ESP32来做一些有意思的东西，我是真的喜欢这款MCU，尤其是Stm32被炒的天价之后。&lt;/p&gt;
&lt;p&gt;但我不太喜欢使用 Arduino IDE，那个实在是太简陋了，写起来总是莫名其妙的样式Bug，有意思的是VSCode支持了这个插件，这就太方便我使用了。&lt;/p</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://magic-matrix.gitee.io/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="单片机" scheme="https://magic-matrix.gitee.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>利用Opencv进行双目标定</title>
    <link href="https://magic-matrix.gitee.io/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/"/>
    <id>https://magic-matrix.gitee.io/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/</id>
    <published>2021-09-16T07:36:08.000Z</published>
    <updated>2021-10-25T07:45:52.760Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间进行了摄像头标定，我使用过matlab直接标定，效果感觉还可以。那么这次纯粹是使用Opencv来进行一次标定。</p><a id="more"></a><h2 id="准备标定板"><a href="#准备标定板" class="headerlink" title="准备标定板"></a>准备标定板</h2><p>标定板是必不可少的，这里我说明一下，建议使用长宽不等的标定板，这样可以避免出现错误的姿态误差。比如我下面准备的图片。</p><p><img src="/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/board.jpeg" alt="board"></p><p>我是直接打印出来，其实并不建议直接打印，因为我打印出来后发现整张纸有点潮，晾干后不太平整，所以并不太建议直接打印。</p><h2 id="标定程序"><a href="#标定程序" class="headerlink" title="标定程序"></a>标定程序</h2><p>先说一下步骤：</p><ul><li>定位出图片中所有的角点</li><li>利用所有的角点去进行单目标定</li><li>利用所有的角点去进行双目标定</li></ul><h3 id="定位角点"><a href="#定位角点" class="headerlink" title="定位角点"></a>定位角点</h3><p>当然，在找点前需要把图片导进来，导进来是一个 <code>numpy</code> 的矩阵，形状为<code>(h, w, 3)</code>。</p><p>接下来我就直接定义了个函数，用来专门定位。</p><p>这个函数简单介绍一下，有两个参数：</p><ul><li><code>image</code>是图片的矩阵</li><li><code>size</code>是标定板的角点的尺寸，上面的那张标定图就是<code>(11, 8)</code></li></ul><p>返回值就只有两种可能，如果能找到就直接返回点，找不到就返回<code>None</code>。</p><p>程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cornerFind</span>(<span class="params">image, size</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    角点查找</span></span><br><span class="line"><span class="string">    :param image: 图片</span></span><br><span class="line"><span class="string">    :param size: 角点个数（横向个数，纵向个数）</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 寻找</span></span><br><span class="line">    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class="number">30</span>, <span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 灰度化</span></span><br><span class="line">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定位角点</span></span><br><span class="line">    success, corners = cv2.findChessboardCorners(gray, size, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> success:</span><br><span class="line">        <span class="comment"># 成功定位到的话</span></span><br><span class="line">        <span class="comment"># 再次使用亚像素定位角点，这样精度更高</span></span><br><span class="line">        output = cv2.cornerSubPix(gray, corners, (<span class="number">11</span>, <span class="number">11</span>), (-<span class="number">1</span>, -<span class="number">1</span>), criteria)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>单张图片定位角点的程序有了，那么就直接使用。</p><p>接下来就是把每次的结果直接放进列表里：</p><ul><li>定义<code>obj_points</code>列表，专门放标定板的坐标</li><li>定义<code>left_img_points</code>列表，专门放左相机拍摄的角点</li><li>定义<code>right_img_points</code>列表，专门放右相机拍摄的角点</li></ul><p>那么，完整的程序就是如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标定板的尺寸</span></span><br><span class="line">board = (<span class="number">11</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 每个块的宽度</span></span><br><span class="line">size = <span class="number">19.2</span></span><br><span class="line"></span><br><span class="line">bw, bh = board</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标定板的坐标</span></span><br><span class="line">objp = np.zeros((bw * bh, <span class="number">3</span>), np.float32)</span><br><span class="line">objp[:, :<span class="number">2</span>] = np.mgrid[<span class="number">0</span>:bw, <span class="number">0</span>:bh].T.reshape(-<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">objp *= size</span><br><span class="line"></span><br><span class="line">obj_points = []  <span class="comment"># 存储标定板的坐标</span></span><br><span class="line">left_img_points = []  <span class="comment"># 存储图片上的</span></span><br><span class="line">right_img_points = []  <span class="comment"># 存储图片上的</span></span><br><span class="line"></span><br><span class="line">image_size = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用循环来读取图片</span></span><br><span class="line"><span class="keyword">for</span> left_path, right_path <span class="keyword">in</span> <span class="built_in">zip</span>(left_image_list, right_image_list):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取图片（左右相机图片）</span></span><br><span class="line">    left_image = cv2.imread(left_path)</span><br><span class="line">    right_image = cv2.imread(right_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图片尺寸</span></span><br><span class="line">    image_size = left_image.shape[<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取角点</span></span><br><span class="line">    left_corners = cornerFind(left_image, board)</span><br><span class="line">    right_corners = cornerFind(right_image, board)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_corners <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (right_corners <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加一个标定板坐标</span></span><br><span class="line">        obj_points.append(objp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加一个图片坐标</span></span><br><span class="line">        left_img_points.append(left_corners)</span><br><span class="line">        right_img_points.append(right_corners)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 画出来</span></span><br><span class="line">        cv2.drawChessboardCorners(left_image, board, left_corners, <span class="literal">True</span>)</span><br><span class="line">        cv2.drawChessboardCorners(right_image, board, right_corners, <span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 画出第一个点</span></span><br><span class="line">        cv2.circle(left_image, left_corners[<span class="number">0</span>, <span class="number">0</span>].astype(<span class="built_in">int</span>), <span class="number">10</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        cv2.circle(right_image, right_corners[<span class="number">0</span>, <span class="number">0</span>].astype(<span class="built_in">int</span>), <span class="number">10</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示出来</span></span><br><span class="line">        <span class="comment"># cv2.imshow(&quot;left&quot;, left_image)</span></span><br><span class="line">        <span class="comment"># cv2.imshow(&quot;right&quot;, right_image)</span></span><br><span class="line">        <span class="comment"># print(left_corners)</span></span><br><span class="line">        <span class="comment"># cv2.waitKey(0)</span></span><br></pre></td></tr></table></figure><p>这里我来说一下<code>size</code>这个变量，Opencv的量纲是毫米，<code>size</code>就是单个方框的尺寸，我打印出来之后测量了一下就是 19.2 mm，所以<code>objp *= size</code>的作用就是，将标定板做成实际坐标。</p><p>看一下效果吧：</p><p><img src="/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/image.jpg" alt="image"></p><h3 id="单目标定"><a href="#单目标定" class="headerlink" title="单目标定"></a>单目标定</h3><p>单目就直接使用<code>cv2.calibrateCamera()</code>就可以直接标定。</p><p>会返回出五个结果，分别是：精度、内参矩阵、畸变参数、旋转矩阵、平移向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左相机标定</span></span><br><span class="line">_, l_mtx, l_dist, _, _ = cv2.calibrateCamera(</span><br><span class="line">    obj_points, left_img_points, image_size, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 右相机标定</span></span><br><span class="line">_, r_mtx, r_dist, _, _  = cv2.calibrateCamera(</span><br><span class="line">    obj_points, right_img_points, image_size, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>在接下来的使用中只会使用到内参矩阵和畸变参数，所以，不会直接使用其他的返回值。</p><h3 id="双目标定"><a href="#双目标定" class="headerlink" title="双目标定"></a>双目标定</h3><p>双目就直接使用<code>cv2.stereoCalibrate()</code>函数。</p><p>返回值是：精度、左相机内参矩阵、左相机畸变参数、右相机内参矩阵、右相机畸变参数、旋转矩阵、平移向量、本征矩阵、基本矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双目相机标定</span></span><br><span class="line">ret, l_mtx, l_dist, r_mtx, r_dist, R, T, E, F = cv2.stereoCalibrate(</span><br><span class="line">    obj_points,                             <span class="comment"># 位置信息</span></span><br><span class="line">    left_img_points, right_img_points,      <span class="comment"># 左右图片的点</span></span><br><span class="line">    l_mtx, l_dist,                 <span class="comment"># 左内参矩阵、畸变参数</span></span><br><span class="line">    r_mtx, r_dist,                 <span class="comment"># 右内参矩阵、畸变参数</span></span><br><span class="line">    image_size)</span><br></pre></td></tr></table></figure><p>说明一下，旋转矩阵和平移向量是第二个相机（右相机）相对于第一个相机而言（左相机）。</p><h3 id="参数保存"><a href="#参数保存" class="headerlink" title="参数保存"></a>参数保存</h3><p>随便使用一个方法把这些参数保存下来，这样就可以下此就直接使用了。</p><p>可以保存成json格式，方便自己私自打开查看。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>以上就是标定的过程，具体的使用还是如下所示。</p><h3 id="去除畸变和图像校正"><a href="#去除畸变和图像校正" class="headerlink" title="去除畸变和图像校正"></a>去除畸变和图像校正</h3><p>标定完了之后，就可以直接使用了，主要是分为两步：</p><ul><li>去除畸变：目的是消除图片的切向畸变和径向畸变</li><li>图像校正：将对应位置进行调平</li></ul><p>这里我就直接使用<code>cv2.stereoRectify()</code>函数和<code>cv2.initUndistortRectifyMap()</code>函数，我再这里直接封装成了一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectifyDistort</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size: <span class="built_in">tuple</span>, datas: <span class="built_in">dict</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算出立体矫正所需要的映射矩阵</span></span><br><span class="line">        R1, R2, P1, P2, Q, validPixROI1, validPixROI2 = cv2.stereoRectify(</span><br><span class="line">            datas[<span class="string">&quot;leftCameraMatrix&quot;</span>], datas[<span class="string">&quot;leftDistCoeffs&quot;</span>],</span><br><span class="line">            datas[<span class="string">&quot;rightCameraMatrix&quot;</span>], datas[<span class="string">&quot;rightDistCoeffs&quot;</span>],</span><br><span class="line">            size, datas[<span class="string">&quot;R&quot;</span>], datas[<span class="string">&quot;T&quot;</span>])</span><br><span class="line"></span><br><span class="line">        self.Q = Q</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左-重映射矩阵</span></span><br><span class="line">        self.left_map = cv2.initUndistortRectifyMap(</span><br><span class="line">            datas[<span class="string">&quot;leftCameraMatrix&quot;</span>],</span><br><span class="line">            datas[<span class="string">&quot;leftDistCoeffs&quot;</span>],</span><br><span class="line">            R1, P1, size, cv2.INTER_NEAREST)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 右-重映射矩阵</span></span><br><span class="line">        self.right_map = cv2.initUndistortRectifyMap(</span><br><span class="line">            datas[<span class="string">&quot;rightCameraMatrix&quot;</span>],</span><br><span class="line">            datas[<span class="string">&quot;rightDistCoeffs&quot;</span>],</span><br><span class="line">            R2, P2, size, cv2.INTER_NEAREST)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, image: np.ndarray, camera: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        校正图</span></span><br><span class="line"><span class="string">        :param image:</span></span><br><span class="line"><span class="string">        :param camera: 摄像头区分</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> camera == <span class="string">&quot;left&quot;</span>:</span><br><span class="line">            map1, map2 = self.left_map</span><br><span class="line">        <span class="keyword">elif</span> camera == <span class="string">&quot;right&quot;</span>:</span><br><span class="line">            map1, map2 = self.right_map</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">        new_image = cv2.remap(image, map1, map2, cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_image</span><br></pre></td></tr></table></figure><p>直接看图片效果。</p><p>未处理图片：</p><p><img src="/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/old_image.jpg" alt="old_image"></p><p>处理图片：</p><p><img src="/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/new_image.jpg" alt="new_image"></p><h3 id="Q矩阵的使用"><a href="#Q矩阵的使用" class="headerlink" title="Q矩阵的使用"></a>Q矩阵的使用</h3><p>在上面的程序中，还会得到一个Q矩阵，这是一个关键的矩阵，可以利用此矩阵直接将世界坐标计算出来。</p><p>公式为：</p><script type="math/tex; mode=display">Q \left[ \begin{matrix} x \\ y \\d \\ 1 \end{matrix} \right] = \left[ \begin{matrix} X \\ Y \\ Z \\ W \end{matrix} \right]</script><p>直接使用Q矩阵乘上一个向量就可以直接得出，世界坐标。</p><p>这里说明两点：</p><ul><li>x、y、d的单位是像素</li><li>X/W，Y/W，Z/W，才是最终的世界坐标，单位是毫米</li><li>d是视差值，左像素和右像素的之差</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间进行了摄像头标定，我使用过matlab直接标定，效果感觉还可以。那么这次纯粹是使用Opencv来进行一次标定。&lt;/p&gt;</summary>
    
    
    
    <category term="机器视觉" scheme="https://magic-matrix.gitee.io/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="双目立体成像" scheme="https://magic-matrix.gitee.io/tags/%E5%8F%8C%E7%9B%AE%E7%AB%8B%E4%BD%93%E6%88%90%E5%83%8F/"/>
    
    <category term="原理" scheme="https://magic-matrix.gitee.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>利用图片加密数据</title>
    <link href="https://magic-matrix.gitee.io/2021/07/%E5%88%A9%E7%94%A8%E5%9B%BE%E7%89%87%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE/"/>
    <id>https://magic-matrix.gitee.io/2021/07/%E5%88%A9%E7%94%A8%E5%9B%BE%E7%89%87%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE/</id>
    <published>2021-07-16T08:07:39.000Z</published>
    <updated>2021-10-16T08:55:11.081Z</updated>
    
    <content type="html"><![CDATA[<p>最近玩了一个很有意思的操作，直接把数据存放在图片中，这种算法有很多种，今天就说一种加密算法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先需要知道像素，有一张三通道的彩色图片，也就是一个 三个维度的矩阵，每个元素的数字的范围是 0~255，很简单，是一个 8 位二进制的数字，总而言言之，每个像素是一个8位的数字。</p><p>三个数值可以直接构成一个像素颜色，也就是RGB（Opencv是使用的BGR，无影响）。那就请看下面的图：</p><p><img src="/2021/07/%E5%88%A9%E7%94%A8%E5%9B%BE%E7%89%87%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE/image.jpg" alt="image"></p><p>你能看出左右红色有什么区别吗？反正我是看不出来，实际上在红色分量上左边是255、右边是254，仅仅差了1，也就是说相差1基本看不出来变化。</p><p>那么把八位的数据拆开，<strong>最后一位是0是1都不会影响颜色太大变化</strong>，因为仅仅相差1。</p><p>所以算法就出来了，首先，把一张图片的所有像素的最后一位变成0，这样肉眼是观查不出问题的。然后我们把需要加密的信息重新拆成二进制形式，补充到最后一位上，还是不会看出来（反正我是看不出来）。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>我也写出来了这部分程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageData</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path: <span class="built_in">str</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取图片</span></span><br><span class="line">        self.imageRead(path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__makeHead</span>(<span class="params">self, length: <span class="built_in">int</span></span>) -&gt; list:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        制作头部数据</span></span><br><span class="line"><span class="string">        :param length: 数据长度</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 数据长度的字节数量，默认成4字节，我感觉足够了</span></span><br><span class="line">        data_max_size = <span class="number">4</span></span><br><span class="line">        <span class="comment"># 头数据长度，默认32字节</span></span><br><span class="line">        head_size = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 两次判断能否放下数据</span></span><br><span class="line">        <span class="keyword">if</span> length + head_size &gt; (<span class="number">1</span> &lt;&lt; (<span class="number">8</span> * data_max_size)):</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">        <span class="keyword">if</span> length + head_size &gt; self.size[<span class="number">0</span>] * self.size[<span class="number">1</span>] * self.size[<span class="number">2</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换成列表</span></span><br><span class="line">        bin_str = <span class="built_in">list</span>(<span class="built_in">bin</span>(length)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 校验标志</span></span><br><span class="line">        bin_num0 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 校验标志</span></span><br><span class="line">        bin_num1 = [<span class="built_in">ord</span>(num_str) - <span class="number">48</span> <span class="keyword">for</span> num_str <span class="keyword">in</span> bin_str]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数据长度的补充</span></span><br><span class="line">        bin_num2 = [<span class="number">0</span> <span class="keyword">for</span> tem <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span> * data_max_size - <span class="built_in">len</span>(bin_num1))]</span><br><span class="line"></span><br><span class="line">        bin_num3 = [<span class="number">0</span> <span class="keyword">for</span> tem <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span> * <span class="number">27</span>)]</span><br><span class="line"></span><br><span class="line">        head = bin_num0 + bin_num2 + bin_num1 + bin_num3</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__binToNumber</span>(<span class="params">self, datas: np.ndarray</span>) -&gt; list:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二进制矩阵转换成十进制列表</span></span><br><span class="line"><span class="string">        :param datas: 二进制矩阵</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取出数据</span></span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">for</span> tem <span class="keyword">in</span> datas:</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> tem2 <span class="keyword">in</span> tem:</span><br><span class="line">                num = num &lt;&lt; <span class="number">1</span></span><br><span class="line">                num += tem2</span><br><span class="line">            data.append(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">saveData</span>(<span class="params">self, numbers: <span class="built_in">list</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将数据藏在图片中</span></span><br><span class="line"><span class="string">        :param numbers: 数据列表</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 计算长度</span></span><br><span class="line">        length = <span class="built_in">len</span>(numbers)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设定数据头部</span></span><br><span class="line">        head = self.__makeHead(length)</span><br><span class="line"></span><br><span class="line">        new_numbers = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数据离散</span></span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="comment"># 转换成列表</span></span><br><span class="line">            bin_list = [(number &gt;&gt; i) &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)][::-<span class="number">1</span>]</span><br><span class="line">            new_numbers += bin_list</span><br><span class="line"></span><br><span class="line">        new_numbers = head + new_numbers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        numbers_1 = np.array(new_numbers, dtype=<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line">        numbers_2 = np.zeros(self.size[<span class="number">0</span>] * self.size[<span class="number">1</span>] * self.size[<span class="number">2</span>] - numbers_1.shape[<span class="number">0</span>], dtype=<span class="string">&#x27;uint8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        data = np.concatenate((numbers_1, numbers_2)).reshape(self.size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 擦除旧数据</span></span><br><span class="line">        self.cleanData()</span><br><span class="line">        self.image += data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadData</span>(<span class="params">self</span>) -&gt; tuple:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        读取藏在图片中的数据</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获得初始的矩阵</span></span><br><span class="line">        data_matrix: np.ndarray = self.image &amp; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 展平</span></span><br><span class="line">        data_matrix = data_matrix.reshape(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 大小</span></span><br><span class="line">        max_length = data_matrix.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去掉无效的部分获得的的长度</span></span><br><span class="line">        max_length = max_length - (max_length % <span class="number">8</span>)</span><br><span class="line">        data_matrix = data_matrix[:max_length]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 8个位一组</span></span><br><span class="line">        data_matrix = data_matrix.reshape((-<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">        head_matrix = data_matrix[<span class="number">0</span>:<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取出头部信息</span></span><br><span class="line">        head = self.__binToNumber(head_matrix)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提取出数据总长度</span></span><br><span class="line">        length = head[<span class="number">4</span>] + (head[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) + (head[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) + (head[<span class="number">1</span>] &lt;&lt; <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">        data_matrix = data_matrix[<span class="number">32</span>:<span class="number">32</span> + length]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取出数据</span></span><br><span class="line">        data = self.__binToNumber(data_matrix)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head, data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cleanData</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        清楚图片中的数据</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.image = self.image &amp; <span class="number">0xfe</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">imageRead</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        读取图片</span></span><br><span class="line"><span class="string">        :param path: 读取图片的路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取图片</span></span><br><span class="line">        image = cv2.imread(path)</span><br><span class="line"></span><br><span class="line">        self.size = image.shape</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 图片转换RGB</span></span><br><span class="line">        self.image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">imageSave</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        保存图片</span></span><br><span class="line"><span class="string">        :param path: 保存图片的路径</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        image = cv2.cvtColor(self.image, cv2.COLOR_RGB2BGR)</span><br><span class="line">        cv2.imwrite(path, image)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">imageShow</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        显示图片</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">&quot;image&quot;</span>, self.image)</span><br><span class="line"></span><br><span class="line">        cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    image = ImageData(<span class="string">&quot;pycharm.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">    image.saveData([<span class="number">178</span>, <span class="number">255</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    head, data = image.loadData()</span><br><span class="line"></span><br><span class="line">    image.imageSave(<span class="string">&quot;a.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序有点长，我简单说一下作用。</p><p>首先我封装成了一个类<code>ImageData</code>，构造函数只有一个参数，就是图片的路径，可以直接加载本地图片。</p><p>加载进图片之后，图片会处于<code>ImageData</code>实例化的对象中，也可以再使用<code>imageRead</code>方法重新加载图片，也可以使用<code>imageSave</code>方法保存该对象中的图片。我也写了一个显示的方法<code>imageShow</code>，直接使用可以直接查看。</p><p>接下来是关于数据的方法：</p><ul><li><code>cleanData</code>方法用于清除图片中的数据，也就是直接将像素中的8位二进制数字的最后一位直接变成0。</li><li><code>saveData</code>方法是将一个列表中的数字藏进图片中，但数字只能是8位二进制数字，有特殊需求可以直接去修改。</li><li><code>loadData</code>方法会返回图片中的数字，会返回两个值，第一个是相关信息，第二个才是隐藏的数据。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近玩了一个很有意思的操作，直接把数据存放在图片中，这种算法有很多种，今天就说一种加密算法。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;首先需要知道像素，有一张三通道的</summary>
      
    
    
    
    <category term="奇妙的原理" scheme="https://magic-matrix.gitee.io/categories/%E5%A5%87%E5%A6%99%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="原理" scheme="https://magic-matrix.gitee.io/tags/%E5%8E%9F%E7%90%86/"/>
    
    <category term="python" scheme="https://magic-matrix.gitee.io/tags/python/"/>
    
    <category term="图像处理" scheme="https://magic-matrix.gitee.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程并发</title>
    <link href="https://magic-matrix.gitee.io/2021/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    <id>https://magic-matrix.gitee.io/2021/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</id>
    <published>2021-07-11T05:40:35.000Z</published>
    <updated>2021-10-16T08:11:29.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><p>为了防止单个程序发生阻塞的现象，所以必须使用多线程或进程来解决此类问题。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>在操作系统中运行的的程序会占用一个进程，进程主要在执行一个程序的过程中，系统会分配给的一些资源给此进程进行执行一些程序，主要针对于硬件产生的一种并发。</p><p>是系统资源分配的基本单位。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程中会分配多个线程，用来是提高某个程序高并发运行。</p><p>是CPU调度和执行的基本单位，真正多线程是多个CPU（多核）共同执行。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>三种方式：</p><ul><li>继承<code>Thread</code>类（重点）</li><li>使用<code>Runnable</code>接口（重点）</li><li>使用<code>Callable</code>接口（了解）</li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承<code>Thread</code>类</h3><p>步骤：</p><ol><li>继承<code>Thread</code>类，重写<code>run</code>方法</li><li>实例化对象，使用<code>start()</code>方法启动</li></ol><p>测试：</p><p>线程1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread_1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread_2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread_2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> other.Thread_1;</span><br><span class="line"><span class="keyword">import</span> other.Thread_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread_1 thread1 = <span class="keyword">new</span> Thread_1();</span><br><span class="line">        Thread_2 thread2 = <span class="keyword">new</span> Thread_2();</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mian&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：开启线程后不会立即执行，由CPU来调度。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h3><p>步骤：</p><ol><li>直接使用<code>Runnable</code>接口来实现一个类</li><li>实现<code>run()</code>方法，重新编写程序执行内容</li><li>实例化<code>Thread</code>类，将线程对象传入其中</li></ol><p>测试：</p><p>线程1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable_1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Runnable_1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable_2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Runnable_2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> other.Runnable_1;</span><br><span class="line"><span class="keyword">import</span> other.Runnable_2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable_1 runnable_1 = <span class="keyword">new</span> Runnable_1();</span><br><span class="line">        Runnable_2 runnable_2 = <span class="keyword">new</span> Runnable_2();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable_1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable_2);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mian&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简写的话可以直接这样写:<code>new Thread(runnable_1).start()</code>。</li><li>本质上，<code>Thread</code>类其实也是实现的<code>Runnable</code>接口。</li><li>更推荐使用<code>Runnable</code>接口，更灵活，方便一个对象被多个线程使用。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>其实<code>Thread</code>具体的实现原理就是使用的代理，使用接口可以巧妙实现<strong>代理</strong>的操作。</p><p>使用结婚来举个例子：</p><ol><li><p>定义一个接口，表示要代理的操作（结婚）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“代理对象”和“真实对象”同时实现这个接口：</p><ul><li><p>真实对象实现接口（人）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚了！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理对象实现接口（婚庆公司）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happyMarry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.target.happyMarry();</span><br><span class="line">        after();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚前做的事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结婚后做的事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处是：</p></li></ul></li></ol><ul><li><strong>代理对象</strong>可以做很多<strong>真实对象</strong>做不了的事</li><li><strong>真实对象</strong>只需要做自己的事就可以</li></ul><p>回头看看<code>Thread</code>这个类，其实就是代理对象，<code>Thread</code>在之前已经实现了<code>Runnable</code>接口，我们使用的时候也实现了<code>Runnable</code>接口，所以在进行多线程的时候，就已经帮我们进行了代理。</p><h2 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h2><p>可以主要简化一些程序的逻辑。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(形参)-&gt;&#123;</span><br><span class="line">    执行内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>任何接口，只有<strong>一个抽象方法</strong>，就说明是一个函数接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况之下可以使用Lamda表达式来去替代这个接口。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个接口，这个接口只有一个方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Temp</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接使用接口去实例化这个对象</span></span><br><span class="line">        Temp temp = (<span class="keyword">int</span> a)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以像普通的对象一样去调用这个方法</span></span><br><span class="line">        temp.fun(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>只有<strong>一行代码</strong>时，可以简化掉花括号</li><li>可以去掉参数类型，但必须统一，<strong>都去掉或都不去掉</strong></li></ul><p>那么关于<code>Runnable</code>接口，就可以直接写成下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// 线程内容</span></span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>一共五种状态，如图所示：</p><p><img src="/2021/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/1631189204.png" alt="1631189204"></p><p>关于线程状态有如下方法：</p><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>setPriority(int newPrivority)</code></td><td>更改优先级</td></tr><tr><td><code>static void sleep(long millis)</code></td><td>指定的毫秒数内进行休眠</td></tr><tr><td><code>void join()</code></td><td>等待线程终止</td></tr><tr><td><code>static void yield()</code></td><td>暂停当前正在执行的线程</td></tr><tr><td><del><code>void interrupt()</code></del></td><td>中断线程（不要使用）</td></tr><tr><td><code>boolean isAlive()</code></td><td>线程是否处于活动状态</td></tr></tbody></table></div><h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>注意：停止一个线程最好使用一个标志位来检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            线程内容</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul><li>可以模拟网络延时、倒计时</li><li>每个对象都有一个锁，sleep不会释放锁</li><li>sleep存在异常，需要向外抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;延时开始&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;延时结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于存在异常，要么抛出异常，要么捕获异常。</p><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>能够让正在运行的线程暂停，但不阻塞，将线程从<strong>运行状态</strong>转换成<strong>就绪状态</strong>。</p><p><strong>注意</strong>：让CPU重新调度，礼让不一定能够成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">        <span class="comment">// 礼让</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><p>可以理解为<strong>插队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;其他线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        </span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程&quot;</span>+i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="comment">// 在200次的时候进行强制插队</span></span><br><span class="line">                thread.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;主线程强制插队&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>少使用，防止阻塞。</p><h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><p>可以使用<code>.getState()</code>方法来观测状态。</p><p>线程的状态在一个枚举里，其中就有：</p><ul><li><code>Thread.State.NEW</code>线程创建</li><li><code>Thread.State.RENNABLE</code>线程运行</li><li><code>Thread.State.TIMED_WAITING</code>线程等待（阻塞）</li><li><code>Thread.State.TERMINATED</code>线程死亡</li></ul><p><strong>注意</strong>：线程死亡后不能重新启动，也就是不能<code>.start()</code></p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>优先级使用数字，范围为：<code>1~10</code>，优先级越高就先执行且分配更高的资源。默认是5优先级</p><p>也可以直接使用静态变量去描述：</p><ul><li><code>Thread.MIN_PRIORITY = 1</code>最小优先级</li><li><code>Thread.MAX_PRIORITY = 10</code>最大优先级</li><li><code>Thread.NORM_PRIORITY = 5</code>默认优先级</li></ul><p>可以使用以下方法去处理优先级：</p><ul><li><code>.getPriority()</code>获取优先级</li><li><code>.setPriority(int xxx)</code>设置优先级</li></ul><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>线程分为用户线程和守护线程。</p><ul><li>虚拟机必须保证用户线程执行完毕</li><li>虚拟机不用等待守护线程执行完毕</li><li>举例：垃圾回收、监控内存、后台记录操作日志</li></ul><p>设置成守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>默认是正常线程，所以是<code>false</code></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>一般会遇到同一个资源多个线程使用。</p><p>实现条件：队列 + 锁</p><p>在每个线程想使用资源的时候先获得对象的排他锁，独占资源，再执行自己的线程使用资源，其他的线程处于等待状态。</p><p>但会出现一些问题：其他线程会等待，效率变低</p><p>可以使用private关键字保证数据对象只能被方法访问，针对这种方法使用一种机制，使用<code>synchronized</code>关键字。</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>当使用<code>synchronized</code>来描述方法的时候就是<strong>同步方法</strong>，每个对象控制一个锁，<code>synchronized</code>方法需要获得这个锁才能执行，否则线程就会堵塞。</p><p>一旦获得这个锁就会执行方法，且独占该锁，直到方法返回才释放该锁，让其他线程可以获得。</p><p>只需要在修改内存的地方使用<code>synchronized</code>方法，因为并不高效。</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建行为</span></span><br><span class="line">        CardShop card = <span class="keyword">new</span> CardShop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建进程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(card,<span class="string">&quot;路人A&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(card,<span class="string">&quot;路人B&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(card,<span class="string">&quot;路人C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动进程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardShop</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> card_number = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 来修饰一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.card_number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 有票就自减一张</span></span><br><span class="line">            <span class="keyword">this</span>.card_number--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示买票者的信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;[&quot;</span>+Thread.currentThread().getName()+  <span class="string">&quot;] 买了一张，还剩&quot;</span> + <span class="keyword">this</span>.card_number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.flag)</span><br><span class="line">            buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p><code>synchronized</code>来修饰方法的时候，只是锁中了这个方法的对象，并没有锁中这个方法中调用的对象，需要这样去写可以锁中一个对象，这样是<strong>同步块</strong>。</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Account account;</span><br><span class="line">    Test(Account account)&#123;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 锁中一个对象</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.account)&#123;</span><br><span class="line">            <span class="comment">// 其他代码，可以安全访问这个对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>可能会出实现两个线程锁住了两个资源，因此不能互相干涉，这时候会出现互相等对方，这样就造成了直接的阻塞，因此这样发生了死锁的问题。</p><p>案例：</p><p>象征着资源的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp1</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp2</span></span>&#123;</span><br><span class="line">    <span class="comment">//第二个资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseTemp</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用 static 保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> Temp1 temp1 = <span class="keyword">new</span> Temp1();</span><br><span class="line">    <span class="keyword">static</span> Temp2 temp2 = <span class="keyword">new</span> Temp2();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> choice;<span class="comment">// 选择</span></span><br><span class="line">    String user;<span class="comment">// 使用者</span></span><br><span class="line">    </span><br><span class="line">    UseTemp(<span class="keyword">int</span> choice, String user)&#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">using</span><span class="params">()</span> throw InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">// 想要持有对方的资源</span></span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(temp1)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.user+ <span class="string">&quot;获得了 temp1&quot;</span>)</span><br><span class="line"><span class="comment">// 获得自己的锁</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(temp2)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.user + <span class="string">&quot;获得了 temp2&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(temp2)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.user+ <span class="string">&quot;获得了 temp2&quot;</span>)</span><br><span class="line"><span class="comment">// 获得自己的锁</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(temp1)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.user + <span class="string">&quot;获得了 temp1&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁的<strong>必然条件</strong>：</p><ul><li>互斥条件：一个资源每次被一个进程使用。</li><li>请求与保持条件：自己拥有资源的时候，想要获得其他资源。</li><li>不剥夺条件：进程已经获得的资源，在没有使用完之前，不得强行剥夺。</li><li>循环等待条件：若干进程之间形成头尾相连等待资源的关系。</li></ul><p>解决的方法就是，<strong>同步块</strong></p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>JDK5.0开始，提供了更强大的线程同步机制——通过显示定义同步锁对象来实现同步。</p><ul><li>使用<code>juc</code>包中的Lock接口：<code>java.util.concurrent.locks.Lock;</code></li><li><code>ReentrantLock</code>实现了 Lock（可重入锁），拥有与<code>synchronized</code>相同的并发性。</li></ul><p>使用方法：</p><ol><li><p>实例化一个Lock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure></li><li><p>加锁的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//锁中的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p></li></ol><ul><li>Lock是显示锁，需要手动<strong>开关</strong>（一定要关上）；<code>synchronized</code>是隐式锁，出了作用域就直接释放。</li><li>Lock只有<strong>代码块锁</strong>，<code>synchronized</code>还有<strong>方法锁</strong>。</li><li>Lock性能更好，JVM会花费更少的时间来调度。</li></ul><h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>指区分开<strong>生产者</strong>和<strong>消费者</strong>，在多线程中需要线程独自去扮演这些角色。</p><p>应用场景：</p><ul><li>生产者生产出来的产品放入仓库中，消费者从仓库中取出来。</li><li>针对生产者：仓库中有产品，生产者直接放入；仓库中没有产品，生产者需要考虑是否继续生产。</li><li>针对消费者：仓库中有产品，消费者直接拿出使用；仓库中没有产品，消费者需要等待生产者生产并放入仓库。</li></ul><p>只有<code>synchronized</code>是不够用的，只能实现<strong>同步</strong>，不能实现<strong>通信</strong>。</p><p>java的Object对象中有以下几个方法：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td><code>wait()</code></td><td>线程会一直等待，直到其他线程通知，与sleep不同，会释放锁</td></tr><tr><td><code>wait(long timeout)</code></td><td>指定等待的毫秒数</td></tr><tr><td><code>notify()</code></td><td>唤醒一个处于等待状态的线程</td></tr><tr><td><code>notifyAll()</code></td><td>唤醒所有等待的线程，优先级越高提前唤醒</td></tr></tbody></table></div><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h4><p>使用另一块缓冲区去管理资源，消费者和生产者能够访问这片区域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span></span>&#123;</span><br><span class="line">    Temp[] temp = <span class="keyword">new</span> Temp[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Temp tem)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 满了就等待消费者消费，生产者停止生产</span></span><br><span class="line">        <span class="keyword">if</span>(count == temp.length)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;停止生产，等待消费&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.temp[count] = tem;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Temp <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 空了就等待生产者生产</span></span><br><span class="line">        <span class="keyword">if</span>(count == temp.length)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;停止消费，等待生产&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        Temp tem = temp[count];</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="标志位法"><a href="#标志位法" class="headerlink" title="标志位法"></a>标志位法</h4><p>不需要定义缓冲区，只需要定义一个标志位，用来判断是否有物品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activate</span></span>&#123;</span><br><span class="line">    Temp tem;</span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Temp tem)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产</span></span><br><span class="line">        <span class="keyword">this</span>.tem = tem;</span><br><span class="line">        <span class="keyword">this</span>.flag = ! <span class="keyword">this</span>.flag</span><br><span class="line">        <span class="comment">// 通知其他接收者</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些基本概念&quot;&gt;&lt;a href=&quot;#一些基本概念&quot; class=&quot;headerlink&quot; title=&quot;一些基本概念&quot;&gt;&lt;/a&gt;一些基本概念&lt;/h2&gt;&lt;p&gt;为了防止单个程序发生阻塞的现象，所以必须使用多线程或进程来解决此类问题。&lt;/p&gt;
&lt;h3 id=&quot;进程&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Matrix的笔记本" scheme="https://magic-matrix.gitee.io/categories/Matrix%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="https://magic-matrix.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft的Mod开发</title>
    <link href="https://magic-matrix.gitee.io/2021/07/Minecraft%E7%9A%84Mod%E5%BC%80%E5%8F%91/"/>
    <id>https://magic-matrix.gitee.io/2021/07/Minecraft%E7%9A%84Mod%E5%BC%80%E5%8F%91/</id>
    <published>2021-07-07T01:07:28.000Z</published>
    <updated>2021-10-14T07:02:33.797Z</updated>
    
    <content type="html"><![CDATA[<p>为了使 Minecraft 的 可玩性更高，但数据包的局限性很大，所以开始开发 mod 来进一步增强游戏体验。</p><p><img src="/2021/07/Minecraft%E7%9A%84Mod%E5%BC%80%E5%8F%91/mc.jpg" alt="mc"></p><p>我所选择的是 fabric 的 mod 开发，原因如下：</p><ul><li><strong>维护方便</strong>，没有使用 forge 的最重要原因就是太麻烦，每次更新会有很大的变化，fabric 最大的优点就是仅仅需要改改版本就可以使用。</li><li><strong>开发方便</strong>，虽然 fabric 没有 forge 更强大，但很大程度上方便开发，对于我来说，在闲暇之余即可开发。</li></ul><h2 id="fabric-的开发环境搭建"><a href="#fabric-的开发环境搭建" class="headerlink" title="fabric 的开发环境搭建"></a>fabric 的开发环境搭建</h2><p>下载 fabric 的工程模板：<a href="https://github.com/FabricMC/fabric-example-mod">GitHub - FabricMC/fabric-example-mod: Example Fabric mod</a></p><p>下载完毕后，cd到文件目录，运行<code>./gradlew genSources</code>来配置环境。</p><p><em>（未完待续，可能永远都不能待续了/(ㄒoㄒ)/~~）</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了使 Minecraft 的 可玩性更高，但数据包的局限性很大，所以开始开发 mod 来进一步增强游戏体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/Minecraft%E7%9A%84Mod%E5%BC%80%E5%8F%91/mc.jpg&quot; alt=&quot;mc</summary>
      
    
    
    
    <category term="Matrix的笔记本" scheme="https://magic-matrix.gitee.io/categories/Matrix%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="Java" scheme="https://magic-matrix.gitee.io/tags/Java/"/>
    
    <category term="游戏" scheme="https://magic-matrix.gitee.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>回顾计算机网络</title>
    <link href="https://magic-matrix.gitee.io/2021/06/%E5%9B%9E%E9%A1%BE%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://magic-matrix.gitee.io/2021/06/%E5%9B%9E%E9%A1%BE%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-06-19T02:26:00.000Z</published>
    <updated>2021-10-14T07:01:06.263Z</updated>
    
    <content type="html"><![CDATA[<p>我在本科的时候比较系统学习过计算机网络，可惜好久不用了，所以，本篇文章是一个复习的笔记，我就挑一些我将来可能用到的东西去详细复习，所以像什么数据链路层和物理层我就不用去复习了（那部分是真的恶心）。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>区分局域网或互联网中的计算机设备。</p><ul><li>每一台电脑有一个 IP 地址。</li><li><code>127.0.0.1</code>为本地 localhost</li></ul><p>程序测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询本地ip地址</span></span><br><span class="line">            <span class="comment">// 可以使用以下方式查询：</span></span><br><span class="line">            <span class="comment">// 1. 127.0.0.1</span></span><br><span class="line">            <span class="comment">// 2. localhost</span></span><br><span class="line">            <span class="comment">// 3. 直接使用.getLocalHost()方法</span></span><br><span class="line">            InetAddress inetAddress1 = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询百度ip地址</span></span><br><span class="line">            InetAddress inetAddress2 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(inetAddress2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnknownHostException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还有一些方法可以直接去获取其他信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inetAddress1.getAddress();             <span class="comment">// Byte 形式的地址（不常用）</span></span><br><span class="line">inetAddress1.getCanonicalHostName();   <span class="comment">// 规范的名字（不常用）</span></span><br><span class="line">inetAddress1.getHostAddress();         <span class="comment">// 获得 ip 地址</span></span><br><span class="line">inetAddress1.getHostName();            <span class="comment">// 获得域名（或者自己电脑名字）</span></span><br></pre></td></tr></table></figure><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>一台计算机上的一个进程。</p><ul><li><p>不同进程有不同端口号，主要用来区分软件。</p></li><li><p>范围为 0~65535.</p></li><li><p>端口号不能冲突。</p></li><li><p>端口分类：</p><ul><li><p>公有端口（0~1023）：</p><p>| 服务协议 | 端口号 |<br>| ———— | ——— |<br>| HTTP     | 80     |<br>| HTTPS    | 443    |<br>| FTP      | 21     |<br>| Telent   | 23     |</p></li><li><p>程序注册端口（1024~49151）：分配给用户</p><p>| 程序   | 端口号 |<br>| ——— | ——— |<br>| Tomcat | 8080   |<br>| MySQL  | 3306   |<br>| Oracle | 1521   |</p></li><li><p>动态、私有端口（49152~65535）：随机分配（尽量不去使用）：</p><ul><li><code>netstat -ano</code>可以查看所有的端口</li><li><code>netstat -ano | findstr &quot;6000&quot;</code>可以查看指定的端口</li><li><code>tasklist | findstr &quot;6000&quot;</code>可以查看指定的端口的进程</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回某个进程的端口号信息</span></span><br><span class="line">        InetSocketAddress socket = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 获取名字</span></span><br><span class="line">        System.out.println(socket.getHostName());</span><br><span class="line">        <span class="comment">// 获取地址</span></span><br><span class="line">        System.out.println(socket.getAddress());</span><br><span class="line">        <span class="comment">// 获取端口号</span></span><br><span class="line">        System.out.println(socket.getPort());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><ul><li>TCP：用户传输协议<ul><li>连接、稳定</li><li>三次握手，四次挥手</li><li>明确服务端和客户端</li><li>效率低</li></ul></li><li>UDP：用户数据报协议<ul><li>不连接、不稳定</li><li>服务端和客户端没有明显明确</li><li>效率高</li><li>DDOS：洪水攻击（饱和攻击）</li></ul></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos= <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 需要有一个地址，设置端口号为 9999</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待客户端连接</span></span><br><span class="line">            <span class="comment">// 监听</span></span><br><span class="line">            socket= serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收消息，实例化IO流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 管道流</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;baos.close();&#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;is.close();&#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                <span class="keyword">try</span> &#123;socket.close();&#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 关闭服务器</span></span><br><span class="line">                <span class="keyword">try</span> &#123;serverSocket.close();&#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 需要连接服务器的地址</span></span><br><span class="line">            InetAddress serverIP = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要连接服务器的端口号</span></span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传入ip和端口，创建一个 socket 连接</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(serverIP, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息，实例化IO流</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送的内容</span></span><br><span class="line">            os.write(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;os.close();&#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                <span class="keyword">try</span> &#123;socket.close();&#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="服务端程序-1"><a href="#服务端程序-1" class="headerlink" title="服务端程序"></a>服务端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DatagramSocket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开放端口</span></span><br><span class="line">            socket = <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接受数据包</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先建一个包，用来接收</span></span><br><span class="line">            DatagramPacket pack = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">            socket.receive(pack);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(pack.getData()));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                <span class="keyword">try</span> &#123;socket.close();&#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端程序-1"><a href="#客户端程序-1" class="headerlink" title="客户端程序"></a>客户端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立数据包连接</span></span><br><span class="line">            DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送的ip地址</span></span><br><span class="line">            InetAddress serverIP=  InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="comment">// 发送的端口</span></span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新建一个包</span></span><br><span class="line">            <span class="comment">// 参数是起始位置和结束位置</span></span><br><span class="line">            String massage = <span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">            DatagramPacket pack = <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">                    massage.getBytes(),          <span class="comment">//发送的数据</span></span><br><span class="line">                    <span class="number">0</span>,                    <span class="comment">//起始位置</span></span><br><span class="line">                    massage.getBytes().length,   <span class="comment">//结束位置</span></span><br><span class="line">                    serverIP,                   <span class="comment">// 接收ip</span></span><br><span class="line">                    port                        <span class="comment">// 端口号</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送包</span></span><br><span class="line">            socket.send(pack);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>统一资源定位符</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议:&#x2F;&#x2F;ip地址:端口号&#x2F;项目名&#x2F;资源</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我在本科的时候比较系统学习过计算机网络，可惜好久不用了，所以，本篇文章是一个复习的笔记，我就挑一些我将来可能用到的东西去详细复习，所以像什么数据链路层和物理层我就不用去复习了（那部分是真的恶心）。&lt;/p&gt;
&lt;h2 id=&quot;IP地址&quot;&gt;&lt;a href=&quot;#IP地址&quot; clas</summary>
      
    
    
    
    <category term="Matrix的笔记本" scheme="https://magic-matrix.gitee.io/categories/Matrix%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="java" scheme="https://magic-matrix.gitee.io/tags/java/"/>
    
    <category term="计算机网络" scheme="https://magic-matrix.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>关于我博客移植到小程序上的那些事</title>
    <link href="https://magic-matrix.gitee.io/2021/05/%E5%85%B3%E4%BA%8E%E6%88%91%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://magic-matrix.gitee.io/2021/05/%E5%85%B3%E4%BA%8E%E6%88%91%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2021-05-17T00:55:13.000Z</published>
    <updated>2021-10-14T07:00:25.299Z</updated>
    
    <content type="html"><![CDATA[<p>如题，我打算把我自己的博客移植，因为感觉有时候从手机上甩给别人一个链接不方便，还是微信小程序更方便一些。</p><p><img src="/2021/05/%E5%85%B3%E4%BA%8E%E6%88%91%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%A4%8D%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/fc3cd489ab144017a145f2d3170w.jpg" alt="fc3cd489ab144017a145f2d3170w" style="zoom: 67%;"></p><h2 id="hexo插件安装"><a href="#hexo插件安装" class="headerlink" title="hexo插件安装"></a>hexo插件安装</h2><p>首先是需要一个插件的，这个插件的是<code>hexo-generator-restful</code>，作用就是可以将 hexo 中的某些东西可以转换生成 restful 接口供其他地方调用。</p><p>这是一个 restful 风格的 json 文件接口，可以直接去访问这个文件，获得静态网页的信息。</p><p>下面是这个插件在 Github 上的说明：</p><p><a href="https://github.com/yscoder/hexo-generator-restful">https://github.com/yscoder/hexo-generator-restful</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>打开 CMD，将路径cd到博客下，直接在 CMD 中打入以下命令就可以安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-restful</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首先打开配置文件_config.yaml，可以通过修改配置文件信息来实现其他功能，但最开始还没有这些配置，需要手动复制以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对外API</span></span><br><span class="line"><span class="attr">restful:</span></span><br><span class="line">  <span class="comment"># site 可配置为数组选择性生成某些属性</span></span><br><span class="line">  <span class="comment"># site: [&#x27;title&#x27;, &#x27;subtitle&#x27;, &#x27;description&#x27;, &#x27;author&#x27;, &#x27;since&#x27;, email&#x27;, &#x27;favicon&#x27;, &#x27;avatar&#x27;]</span></span><br><span class="line">  <span class="attr">site:</span> <span class="literal">true</span>        <span class="comment"># hexo.config mix theme.config</span></span><br><span class="line">  <span class="attr">posts_size:</span> <span class="number">10</span>    <span class="comment"># 文章列表分页，0 表示不分页</span></span><br><span class="line">  <span class="attr">posts_props:</span>      <span class="comment"># 文章列表项的需要生成的属性</span></span><br><span class="line">    <span class="attr">title:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">slug:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">updated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">excerpt:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">cover:</span> <span class="literal">true</span>      <span class="comment"># 封面图，取文章第一张图片</span></span><br><span class="line">    <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">keywords:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span>         <span class="comment"># 分类数据</span></span><br><span class="line">  <span class="attr">use_category_slug:</span> <span class="literal">true</span> <span class="comment"># Use slug for filename of category data</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="literal">true</span>               <span class="comment"># 标签数据</span></span><br><span class="line">  <span class="attr">use_tag_slug:</span> <span class="literal">true</span>      <span class="comment"># Use slug for filename of tag data</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>               <span class="comment"># 文章数据</span></span><br><span class="line">  <span class="attr">pages:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面是官方给的一个模板，我就没怎么修改了，有些设置感觉没必要，这些信息就足够了，所以就暂时这样。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>以上配置完成后，就可以先使用<code>hexo g</code>命令来静态编译一下，注意一定要有上面的那些命令，否则会出现一些错误。</p><p>在博客的环境下有一个<code>api</code>文件夹，里面就是一些自己编译出来的接口，所以直接使用即可。</p><p><em>（长期更新，未完待续）</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如题，我打算把我自己的博客移植，因为感觉有时候从手机上甩给别人一个链接不方便，还是微信小程序更方便一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/05/%E5%85%B3%E4%BA%8E%E6%88%91%E5%8D%9A%E5%AE%A2%E7%A7%BB%E6%</summary>
      
    
    
    
    <category term="搭建博客" scheme="https://magic-matrix.gitee.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://magic-matrix.gitee.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="前端" scheme="https://magic-matrix.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>那些年，我玩的C++</title>
    <link href="https://magic-matrix.gitee.io/2021/05/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%8E%A9%E7%9A%84C++/"/>
    <id>https://magic-matrix.gitee.io/2021/05/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%8E%A9%E7%9A%84C++/</id>
    <published>2021-05-04T01:46:00.000Z</published>
    <updated>2021-10-14T07:00:35.956Z</updated>
    
    <content type="html"><![CDATA[<p>我尝试过很多使用C++版本的东西，opencv、libtorch、qt，不得不说真的快，所以这篇文章来谈谈，在Clion 上折腾的一些东西。</p><h2 id="Clion-上使用-OpenCV"><a href="#Clion-上使用-OpenCV" class="headerlink" title="Clion 上使用 OpenCV"></a>Clion 上使用 OpenCV</h2><p>了解我的人都知道我非常喜欢使用 JetBrains 公司的软件，所以使用C++的时候选择了 Clion ，但这款软件使用 OpenCV 的时候有些麻烦，我也是好不容易克服了这些。</p><p>因为 Clion 使用的是 CMake 来管理编译环境，所以我先写一下我使用的时候怎么配置的<code>CMakeLists.txt</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.16)</span><br><span class="line"></span><br><span class="line"># 修改这个地方，用来直接设置项目名称</span><br><span class="line">set(MY_PROJECT_NAME OpenCV)</span><br><span class="line"># 修改这个地方，可以直接设置 OpenCV 的路径</span><br><span class="line">set(OpenCV_DIR &quot;D:\\Software\\Languages\\C++\\opencv\\mingw-build\\install&quot;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line">set(OpenCV_LIBS opencv_core opencv_imgproc opencv_highgui opencv_imgcodecs)</span><br><span class="line"></span><br><span class="line">project(MY_PROJECT_NAME)</span><br><span class="line"></span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(MY_PROJECT_NAME main.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(MY_PROJECT_NAME $&#123;OpenCV_LIBS&#125;)</span><br></pre></td></tr></table></figure><p>我标出了两个地方，针对不同的项目修改不同的名字，不建议去详细了解它。</p><p>配置完CMake，那么就可以使用这个头文件了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是一个涵盖了所有头文件的头文件，直接使用其实会影响编译速度，根据自己需求去调用吧。</p><p>首先写几个程序尝尝鲜。</p><h3 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::imread(<span class="string">&quot;D:\\Desktop\\image.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没载入图片的话就停止</span></span><br><span class="line">    <span class="keyword">if</span>(image.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建窗口，窗口尺寸设置成自动</span></span><br><span class="line">    cv::namedWindow(<span class="string">&quot;image&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图片</span></span><br><span class="line">    cv::imshow(<span class="string">&quot;image&quot;</span>, image);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是0，就会持续显示</span></span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除内存，清除所有窗口</span></span><br><span class="line">    cv::destroyAllWindows();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="显示视频"><a href="#显示视频" class="headerlink" title="显示视频"></a>显示视频</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个视频对象</span></span><br><span class="line">    cv::VideoCapture cap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个视频</span></span><br><span class="line">    cap.open(<span class="string">&quot;D:\\Desktop\\test.avi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Mat 对象，用来暂存一帧图像</span></span><br><span class="line">    cv::Mat frame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建窗口，窗口尺寸设置成自动</span></span><br><span class="line">    cv::namedWindow(<span class="string">&quot;video&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 获取一帧图片</span></span><br><span class="line">        cap &gt;&gt; frame;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有图片了就停下来</span></span><br><span class="line">        <span class="keyword">if</span>(frame.empty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示图片</span></span><br><span class="line">        cv::imshow(<span class="string">&quot;video&quot;</span>, frame);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示一帧图像等待 33 毫秒</span></span><br><span class="line">        <span class="comment">// 按到键盘就退出</span></span><br><span class="line">        <span class="keyword">if</span>(cv::waitKey(<span class="number">33</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Clion上使用Libtorch"><a href="#Clion上使用Libtorch" class="headerlink" title="Clion上使用Libtorch"></a>Clion上使用Libtorch</h2><p>Pytorch有C++版本的！！！</p><p>这就很开心了，我终于可以这样使用C++了。</p><h3 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h3><p>去官网下载，其实就是一个压缩文件，解压就可以用了。</p><p>地址：<a href="https://pytorch.org/">PyTorch</a></p><p>往常一样，选择C++那个选项，并选择使用了CPU版本。</p><p><img src="/2021/05/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E7%8E%A9%E7%9A%84C++/2021-05-31_13-09-10.png" alt="2021-05-31_12-57-45"></p><p>其实是有两个的上面的是release版本，下面的是debug版本，我选的是release，毕竟下面debug的还是不小。</p><p>点击就可以下载，等几分钟就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我尝试过很多使用C++版本的东西，opencv、libtorch、qt，不得不说真的快，所以这篇文章来谈谈，在Clion 上折腾的一些东西。&lt;/p&gt;
&lt;h2 id=&quot;Clion-上使用-OpenCV&quot;&gt;&lt;a href=&quot;#Clion-上使用-OpenCV&quot; class=&quot;h</summary>
      
    
    
    
    <category term="Matrix的笔记本" scheme="https://magic-matrix.gitee.io/categories/Matrix%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="图像处理" scheme="https://magic-matrix.gitee.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="C++" scheme="https://magic-matrix.gitee.io/tags/C/"/>
    
    <category term="人工智能" scheme="https://magic-matrix.gitee.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>3d打印机，起飞！！</title>
    <link href="https://magic-matrix.gitee.io/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/"/>
    <id>https://magic-matrix.gitee.io/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/</id>
    <published>2021-04-28T02:21:39.000Z</published>
    <updated>2021-10-14T06:59:41.760Z</updated>
    
    <content type="html"><![CDATA[<p>我终于做好了一台3d打印机！！</p><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/fun.jpeg" alt="fun" style="zoom:50%;"></p><p>说到底最重要的是打印机的程序，我直接使用了开源的 Marlin，这样我还可以在这基础上添加我自己的程序。</p><h2 id="配置Marlin固件"><a href="#配置Marlin固件" class="headerlink" title="配置Marlin固件"></a>配置Marlin固件</h2><p>说来有意思，我最近在整一些arduino的东西，没想到Marlin固件也是基于arduino而开发，这就省事了好多，所以直接下载Marlin就行了源代码就可以了。</p><p>Marlin官网：<a href="http://marlinfw.org/">http://marlinfw.org/</a></p><p>我下载的是<code>1.1.9.1</code>版本的固件，实际上是无所谓，也就是多多少少有些地方会有所不同。</p><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/2021-04-28_10-35-05.png" alt="2021-04-28_10-35-05"></p><p>下载之后会有一个 arduino 项目文件，所以直接使用 arduino IDE 打开就可以。</p><p>这个项目中其他文件尽量不要去修改，因为涉及到一些单片机的程序，当然我肯定会自己修改，毕竟我是</p><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/image2.jpeg" alt="image2"></p><p>当然，有个文件还是需要修改的，找到<code>Configuration.h</code>，你可以叫这个文件为配置文件（好low的名字），打开之后，如果你会 C/C++ 的话，你就会发现里面全是<strong>宏定义</strong>，这就有意思了（我超爱宏定义的）。</p><p>接下来我会说一下比较重要或需要修改的宏定义。</p><h4 id="串口设置"><a href="#串口设置" class="headerlink" title="串口设置"></a>串口设置</h4><p>这个主板与电脑通信使用的是串口通信，所以需要设置一下端口号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERIAL_PORT 0</span></span><br></pre></td></tr></table></figure><p>端口号默认是0，还可以选择其他端口号。</p><p>波特率使用默认的 250000 就可以，其实我在以前玩单片机的时候还没用过这么大的波特率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BAUDRATE 250000</span></span><br></pre></td></tr></table></figure><h4 id="主板选择"><a href="#主板选择" class="headerlink" title="主板选择"></a>主板选择</h4><p>这一条语句是设置你当前使用的是什么主板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MOTHERBOARD</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> MOTHERBOARD BOARD_RAMPS_14_EFB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我就不讲<code>#ifndef</code>是什么意思了，毕竟 C/C++ 的知识。主板的型号在<code>boards.h</code>中，打开就可以看到各种型号。</p><p>我就选择的是<code>BOARD_RAMPS_14_EFB</code>主板，别问我为什么，我买的主板店家就这样告诉我的。</p><h4 id="挤出机设置"><a href="#挤出机设置" class="headerlink" title="挤出机设置"></a>挤出机设置</h4><p>一般情况就使用一个挤出机就够了，所以需要设置成一个挤出机（其实默认就是一个）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTRUDERS 1</span></span><br></pre></td></tr></table></figure><p>耗材的直径最好修改一下，默认为 3.0 ，改成1.75，虽然我感觉这个修改可能用不上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_NOMINAL_FILAMENT_DIA 1.75</span></span><br></pre></td></tr></table></figure><h4 id="热传感器设置"><a href="#热传感器设置" class="headerlink" title="热传感器设置"></a>热传感器设置</h4><p>传感器需要自己好好检查一下自己选择的传感器型号，然后再去设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_SENSOR_0 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_SENSOR_1 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_SENSOR_2 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_SENSOR_3 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_SENSOR_4 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_SENSOR_BED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEMP_SENSOR_CHAMBER 0</span></span><br></pre></td></tr></table></figure><p>简单说一下，0 代表了不适用任何热传感器；1 代表了 100K 的热敏电阻，这是最常用的；其他的选择就看源代码中的程序吧。</p><p>我需要一个热传感器，这是用来控制喷头的温度，所以是必须的；其次我还在热床的位置添加了一个温控，所以<code>TEMP_SENSOR_BED</code>也需要设置成 1 。</p><p>接下来最好修改一下工作温度的范围，在这个区间里才会正常工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_0_MINTEMP 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_1_MINTEMP 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_2_MINTEMP 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_3_MINTEMP 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_4_MINTEMP 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BED_MINTEMP 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_0_MAXTEMP 275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_1_MAXTEMP 275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_2_MAXTEMP 275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_3_MAXTEMP 275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEATER_4_MAXTEMP 275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BED_MAXTEMP 80</span></span><br></pre></td></tr></table></figure><p>我建议热床的最大温度还是调低一些，直接 150 度的话就烧了，我就设置成 80 度了。</p><h4 id="限位开关"><a href="#限位开关" class="headerlink" title="限位开关"></a>限位开关</h4><p>下面这个宏定义是默认打开的，不用去修改它，它的作用是限位开关有<strong>最小值</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_XMIN_PLUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_YMIN_PLUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_ZMIN_PLUG</span></span><br></pre></td></tr></table></figure><p>除此之外，所有<strong>最小值</strong>宏定义被注释上了，因为我使用了双 Z 轴，所以我需要打开一个宏定义，X轴的最大值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_XMAX_PLUG</span></span><br></pre></td></tr></table></figure><p>我用的这些限位开关是机械式的微动开关，需要长期打开的，所以就需要把下面的 false 改成 true，如果使用的是光电对管，这就不需要常开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_MIN_ENDSTOP_INVERTING true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_MIN_ENDSTOP_INVERTING true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_MIN_ENDSTOP_INVERTING true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_MAX_ENDSTOP_INVERTING true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_MAX_ENDSTOP_INVERTING true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_MAX_ENDSTOP_INVERTING true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_MIN_PROBE_ENDSTOP_INVERTING true</span></span><br></pre></td></tr></table></figure><h4 id="电机驱动"><a href="#电机驱动" class="headerlink" title="电机驱动"></a>电机驱动</h4><p>我的打印机使用了5个步进电机，其中 Z 轴就有两个，所以需要这样打开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_DRIVER_TYPE  TMC2208</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_DRIVER_TYPE  TMC2208</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DRIVER_TYPE  TMC2208</span></span><br><span class="line"><span class="comment">//#define X2_DRIVER_TYPE A4988</span></span><br><span class="line"><span class="comment">//#define Y2_DRIVER_TYPE A4988</span></span><br><span class="line"><span class="comment">//#define Z2_DRIVER_TYPE A4988</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E0_DRIVER_TYPE TMC2208</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E1_DRIVER_TYPE TMC2208</span></span><br><span class="line"><span class="comment">//#define E2_DRIVER_TYPE A4988</span></span><br><span class="line"><span class="comment">//#define E3_DRIVER_TYPE A4988</span></span><br><span class="line"><span class="comment">//#define E4_DRIVER_TYPE A4988</span></span><br></pre></td></tr></table></figure><p>另外，我使用的是<code>TMC2208</code>的驱动，所以需要修改成这个驱动的宏。</p><p>然后是动能部分，推荐一个网站，这个网站可以算出合适的参数：</p><p><a href="https://blog.prusaprinters.org/calculator_3416/">https://blog.prusaprinters.org/calculator_3416/</a></p><p>先设置 X 和 Y 轴的步进电机，这两个步进电机是是使用同步带传动，所以直接填入就可以</p><p>我使用的是<code>TMC2208</code>，可以直接挑战32细分，使用的同步轮是20，下图是我所填入的设置还有计算出来的结果：</p><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/2021-04-28_13-48-05.png" alt="2021-04-28_13-48-05"></p><p>我得到的结果为<strong>160</strong>，一会设置的时候，X 和 Y 都要设置成 160。</p><p>除了传送带，还有丝杆的电机也需要计算我用的是 8 毫米直径的丝杆：</p><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/2021-04-28_14-02-20.png" alt="2021-04-28_14-02-20"></p><p>挤出机我用的是泰坦挤出机，大概450左右，后期再精细调节。</p><p>将这些算出来，直接填入下面的数组中，四个数分别对应X、Y、Z、挤出机四种步进电机的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_AXIS_STEPS_PER_UNIT   &#123; 160, 160, 800, 450 &#125;</span></span><br></pre></td></tr></table></figure><p>同时需要设置电机最大速度，可以把 Z 轴和挤出机的速度提高一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_FEEDRATE          &#123; 300, 300, 20, 50 &#125;</span></span><br></pre></td></tr></table></figure><p>启动加速度值，可以随便调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_ACCELERATION      &#123; 2000, 2000, 100, 10000 &#125;</span></span><br></pre></td></tr></table></figure><p>加速度值，可以随便调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_ACCELERATION          2000    <span class="comment">// X, Y, Z 和 E 打印移动的加速度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_RETRACT_ACCELERATION  3000    <span class="comment">// E acceleration for retracts</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_TRAVEL_ACCELERATION   2000    <span class="comment">// X, Y, Z 移动（非打印）的加速度</span></span></span><br></pre></td></tr></table></figure><p>点击正反相问题有两种解决方法，第一种是修改接线，第二种是修改下面的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVERT_X_DIR false</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVERT_Y_DIR true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVERT_Z_DIR false</span></span><br></pre></td></tr></table></figure><p>由于归航的时候使用的都是最小值，所以全部都使用最小值（-1代表最小，1代表最大）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_HOME_DIR -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_HOME_DIR -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_HOME_DIR -1</span></span><br></pre></td></tr></table></figure><h4 id="限定位置"><a href="#限定位置" class="headerlink" title="限定位置"></a>限定位置</h4><p>最主要的是设置热床的尺寸，这个就要根据自己的选择了，我使用的是220大小的热床，我留了一些余量，直接200：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_BED_SIZE 200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_BED_SIZE 200</span></span><br></pre></td></tr></table></figure><p>接下来就是归航的范围，注意最后一个是打印的高度，根据自己搭建的最大值去设置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归位后行程限值（mm），对应于终点位置。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_MIN_POS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_MIN_POS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_MIN_POS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_MAX_POS X_BED_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y_MAX_POS Y_BED_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_MAX_POS 190</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="预热常数"><a href="#预热常数" class="headerlink" title="预热常数"></a>预热常数</h4><p>根据自己需要去设置，我的是使用的是PLA，所以设置成 210 度，热床 60 度；如果使用的是TPU的话是230度，热床 50 度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREHEAT_1_TEMP_HOTEND 210 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREHEAT_1_TEMP_BED     60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREHEAT_1_FAN_SPEED     0 <span class="comment">// Value from 0 to 255</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREHEAT_2_TEMP_HOTEND 240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREHEAT_2_TEMP_BED    110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREHEAT_2_FAN_SPEED     0 <span class="comment">// Value from 0 to 255</span></span></span><br></pre></td></tr></table></figure><h4 id="LCD设置"><a href="#LCD设置" class="headerlink" title="LCD设置"></a>LCD设置</h4><p>这是我的强项了，我最喜欢玩屏了，可惜的是我买的是12864，很low的一款屏，有时间我魔改一下换成tft的彩屏。</p><p>12864是可以设置成中文的，所以在这个位置改成中文：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LCD_LANGUAGE cn</span></span><br></pre></td></tr></table></figure><p>遗憾的是，没有字库文件，所以需要添加进来字库文件。</p><p>对了，我买的不是普通的12864，是一种小款的屏幕，如图：</p><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/2021-04-28_17-16-10.png" alt="2021-04-28_17-16-10" style="zoom:50%;"></p><p>建议直接查找这个宏，然后再打开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKS_MINI_12864</span></span><br></pre></td></tr></table></figure><h4 id="SD卡设置"><a href="#SD卡设置" class="headerlink" title="SD卡设置"></a>SD卡设置</h4><p>我需要用到SD卡来导入文件，所以需要打开这个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SD_CHECK_AND_RETRY</span></span><br></pre></td></tr></table></figure><h4 id="蜂鸣器设置"><a href="#蜂鸣器设置" class="headerlink" title="蜂鸣器设置"></a>蜂鸣器设置</h4><p>我这个提供了一个蜂鸣器，所以我打算使用上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPEAKER</span></span><br></pre></td></tr></table></figure><h4 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h4><p>设置一下打印机的名字，这些字符会在打印机就绪的时候显示出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUSTOM_MACHINE_NAME <span class="meta-string">&quot;Magic-Matrix&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="最后的设置"><a href="#最后的设置" class="headerlink" title="最后的设置"></a>最后的设置</h4><p>以上部分大致设置完毕了，但双Z轴还没有设置成功，所以需要设置一下双Z轴。</p><p>打开<code>Configuration_adv.h</code>头文件，这个头文件是高级配置，接下来我需要在这里去配置。</p><p>找到一下宏定义，并配置成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双 Z 轴步进电机驱动</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DUAL_STEPPER_DRIVERS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLED(Z_DUAL_STEPPER_DRIVERS)</span></span><br><span class="line">  <span class="comment">// 双限位开关</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> Z_DUAL_ENDSTOPS</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> ENABLED(Z_DUAL_ENDSTOPS)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Z2_USE_ENDSTOP _XMAX_</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> Z_DUAL_ENDSTOPS_ADJUSTMENT  0</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="Simplify3D设置"><a href="#Simplify3D设置" class="headerlink" title="Simplify3D设置"></a>Simplify3D设置</h2><p>3D打印机是不可以直接使用 stl 模型的，所以在这之前需要进行切片处理。我使用的切片软件为Simplify3D，简称 S3D，这款软件真的很强，不得不佩服，接下来说一下我自己的设置内容。</p><h4 id="挤出机设置-1"><a href="#挤出机设置-1" class="headerlink" title="挤出机设置"></a>挤出机设置</h4><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/2021-05-06_17-06-54.png" alt="2021-05-06_17-06-54" style="zoom:80%;"></p><p>这里最需要设置的有两个，一个是喷嘴口径，我使用的是0.4mm的喷嘴；另一个设置的是挤出倍率，这个需要慢调，表面太稀疏了就调大，太堆积了就调小。</p><p>其次就是回抽设置，如果没有回抽的话会出现很严重的拉丝现象。我是使用的是近程挤出机，所以，我适当调小了回抽距离，远程挤出可以考虑加大一下。</p><h4 id="温度设置"><a href="#温度设置" class="headerlink" title="温度设置"></a>温度设置</h4><p><img src="/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/2021-05-06_17-20-40.png" alt="2021-05-06_17-20-40" style="zoom:67%;"></p><p>我使用的是PLA材料，温度需要控制在210左右，温度低会黏着不好，温度太高会有点变形，设置成210就差不多了。</p><p>热床就定在60度就可以了。</p><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>这款软件可以自定义脚本，但我没有去写多余的脚本，我只写了一个结束脚本。</p><p>当打印结束的时候，X轴会移到中间，Y轴会伸到前面，这样做的目的就是方便拿起打印的物体。</p><p>脚本程序为（分号是注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M104 S0 ; turn off extruder</span><br><span class="line">M140 S0 ; turn off bed</span><br><span class="line">M84 ; disable motors</span><br><span class="line">G1 X100 Y200</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我终于做好了一台3d打印机！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/04/3d%E6%89%93%E5%8D%B0%E6%9C%BA%EF%BC%8C%E8%B5%B7%E9%A3%9E%EF%BC%81%EF%BC%81/fun.jpeg&quot; alt=&quot;fun&quot; </summary>
      
    
    
    
    <category term="我的发布会" scheme="https://magic-matrix.gitee.io/categories/%E6%88%91%E7%9A%84%E5%8F%91%E5%B8%83%E4%BC%9A/"/>
    
    
    <category term="单片机" scheme="https://magic-matrix.gitee.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>我的MatrixGame</title>
    <link href="https://magic-matrix.gitee.io/2021/04/%E6%88%91%E7%9A%84MatrixGame/"/>
    <id>https://magic-matrix.gitee.io/2021/04/%E6%88%91%E7%9A%84MatrixGame/</id>
    <published>2021-04-20T09:01:17.000Z</published>
    <updated>2021-10-14T07:00:07.891Z</updated>
    
    <content type="html"><![CDATA[<p>我很喜欢 arduboy 这个小东西，但一开始我对 arduino 抵触很大，所以有点看不起 arduino，但这几天我不得不说：</p><p><img src="/2021/04/%E6%88%91%E7%9A%84MatrixGame/inaimg.jpeg" alt="inaimg"></p><p>我之所以看不起arduino就是因为总有一部分人认为自己会个arduino编程就以为自己可以挑战嵌入式，与其说讨厌arduino，不如说讨厌这群人……好了，废话少说，开始介绍这段时间的项目。</p><p>我是打算制作arduboy的，说真的这个小东西还真是优雅。</p><p><img src="/2021/04/%E6%88%91%E7%9A%84MatrixGame/Arduboy_03.jpg" alt="Arduboy_03"></p><p>这款游戏机主要芯片为 ATmega32u4 ，性能肯定没有stm32强悍，当然还是AVR加购，我是有考虑要不要将这个库移植到stm32上去，但我没有那么多时间，还是不要自己造轮子了。</p><p>绘制PCB使用的是立创EDA，本来是使用的AD的，但我意外发现立创EDA格外的好用，而且我在嘉立创打样，所以整体下来轻松了不少。</p><p>就这样，开始了这个项目，接下来我会介绍我制作每个版本的特点。</p><h2 id="MatrixGame-V1"><a href="#MatrixGame-V1" class="headerlink" title="MatrixGame_V1"></a>MatrixGame_V1</h2><p>这是，梦开始的地方……</p><p>绘制一个原理图：</p><p><img src="/2021/04/%E6%88%91%E7%9A%84MatrixGame/Schematic_MatrixBoy.png" alt="Schematic_MatrixBoy"></p><p>这是最初的板子原理图，有很多bug，但在这个原理图之前已经修改过来了。</p><p>于是就开始绘制PCB：</p><p><img src="/2021/04/%E6%88%91%E7%9A%84MatrixGame/2021-04-24_17-22-00.png" alt="2021-04-24_17-22-00" style="zoom:50%;"></p><p><img src="/2021/04/%E6%88%91%E7%9A%84MatrixGame/2021-04-24_17-22-26.png" alt="2021-04-24_17-22-26" style="zoom:50%;"></p><p>这一代板子有个致命的错误，我把电源画反了，导致第一次上电直接冒烟了（唉，差点废一个芯片）。</p><p>而且我的TYPE-C母座和绘制的封装买的有点不一致，基本焊不上，而且TYPE-C是双向的接口，可以正插和反插，但这个有个问题是使用的是交替接的引脚，所以USB直接不能用。</p><p>整体下来，上面的错误就是本次最大的错误，整体下来是能运行的。</p><h2 id="MatrixGame-V2"><a href="#MatrixGame-V2" class="headerlink" title="MatrixGame_V2"></a>MatrixGame_V2</h2><p><img src="/2021/04/%E6%88%91%E7%9A%84MatrixGame/2021-04-24_17-33-52.png" alt="2021-04-24_17-33-52" style="zoom:50%;"></p><p><img src="/2021/04/%E6%88%91%E7%9A%84MatrixGame/2021-04-24_17-34-06.png" alt="2021-04-24_17-34-06" style="zoom:50%;"></p><p>这一代有很大的改变，首先原先的错误修复了过来，原先的按键地方已经掏空，打算使用新的按键（新按键按着很舒服）；其次，部分元器件位置有所调整 ，这样下来布线就会更好一点，当然接下来我会继续修改这些位置。最后去掉了两个灯，因为没什么用，浪费，还难看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我很喜欢 arduboy 这个小东西，但一开始我对 arduino 抵触很大，所以有点看不起 arduino，但这几天我不得不说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/04/%E6%88%91%E7%9A%84MatrixGame/inaimg.jpeg&quot; alt</summary>
      
    
    
    
    <category term="我的发布会" scheme="https://magic-matrix.gitee.io/categories/%E6%88%91%E7%9A%84%E5%8F%91%E5%B8%83%E4%BC%9A/"/>
    
    
    <category term="单片机" scheme="https://magic-matrix.gitee.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>PID控制算法详解</title>
    <link href="https://magic-matrix.gitee.io/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://magic-matrix.gitee.io/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-03T12:26:27.000Z</published>
    <updated>2021-10-14T07:00:01.020Z</updated>
    
    <content type="html"><![CDATA[<p>PID控制算法可以说是我比较早听说的算法了，但几年前我并不太了解原理，我只能按照公式敲除代码，但经过考研之后，我的高数进一步提高，有些东西我逐渐看透了。</p><p><img src="/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/bsuitang.jpeg" alt="bsuitang" style="zoom: 33%;"></p><p>本篇文章我将详细讲解我对PID控制算法理解。</p><p>首先，什么是PID，估计有人一脸懵逼的进来，还不知道什么是PID吧。</p><p>PID是一个控制算法，小到风扇调速，大到火箭轨道调整，都能有它的痕迹。</p><p>我会根据下面这个视频进一步讲解。</p><iframe src="//player.bilibili.com/player.html?aid=627065033&bvid=BV1et4y1i7Gm&cid=235144459&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><hr><p>首先我先放出PID的图：</p><p><img src="/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/20181216103726414.png" alt="20181216103726414"></p><p>不难发现PID是一个闭环系统，问题来了，什么是闭环系统？什么是开环系统？</p><ul><li>开环系统亦称“无反馈系统”，系统的输入影响输出而不受输出影响的系统。简单来讲就是我行我素，我直接输出。</li><li>闭环系统亦称“反馈系统”，系统的输入影响输出同时又受输出的直接或间接影响的系统。简单来讲就是我必须时刻检查我自己的情况，根据我自己的情况来进行输出。</li></ul><p>由此可见闭环系统下需要至少一个传感器，用来检查自身情况。自身情况可以这样判断，因为我们需要一个目标值，由于使用了传感器，所以我还有一个检测值，那我就定义了一个变量：</p><script type="math/tex; mode=display">error = 目标值 - 检测值</script><p>我们可以这样理解 error 这个值，这是一个偏差，当前位置距离目标的一个差，如图下图所示，无人机想飞到白线的高度，但当前检测的高度和目标的高度有个偏差，就是红箭头标出来的偏差。</p><p><img src="/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/2021-04-03_20-55-36.png" alt="2021-04-03_20-55-36"></p><p>那怎么使用这个偏差去控制无人机的输出？按照下面的公式，或者你看上面那个框架图。</p><script type="math/tex; mode=display">u(t) = K_P P + K_I I + K_D D</script><script type="math/tex; mode=display">\begin{cases} P = e(t) \\I = \int_0^t e(\tau) d\tau \\D = \frac{de(t)}{dt}\end{cases}</script><p>一些说明：</p><ul><li>$u(t)$是输出</li><li>$e(t)$是输入</li><li>$K_P , K_I , K_D$这三个值是权重</li></ul><p>这样下来没多难，无非就是把输入积分和微分累加一起，但它的具体原理可以说非常巧妙。</p><p>一般说调参，就是值调节$K_P , K_I , K_D$这三个值，这三个值就是调节这三个部分的大小，比如我只重视“比例”部分，也就是“P”部分，可以让$K_I , K_D$都为零，$K_P$不为零，这样保证了只使用了“P”部分。</p><p>接下来就说明一下每个部分的作用：</p><h3 id="比例（P）"><a href="#比例（P）" class="headerlink" title="比例（P）"></a>比例（P）</h3><p>之所以叫他比例，是因为它是最主要的控制，想象一下，$K_I , K_D$都为零，如果偏差（也就是$e(t)$）特别大，产生的输出也会特别大，这样就可以快速的向目标值靠拢，如果偏差特变小，那输出也会特别小，缓慢靠近目标值。</p><p>但有一个缺点，就是会在目标值进行震荡，这是无法避免的，但可以调节$K_P$这个值控制震荡大小。如果这个值大了，靠近目标的速度会很快，但震荡的幅度会很大；如果小了，震荡的幅度会变小，但靠近目标的速度会很慢。</p><p>两个极端都不是我们想要的，所以需要合理去调节。</p><h3 id="微分（D）"><a href="#微分（D）" class="headerlink" title="微分（D）"></a>微分（D）</h3><p>还是看这个图：</p><p><img src="/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/2021-04-03_20-55-36.png" alt="2021-04-03_20-55-36"></p><p>如果我们对这个偏差进行微分会得到什么？距离的微分是速度，没错微分部分是对速度非常敏感，如果有速度，它才会有值，而且速度和它是正比的关系，拿它有什么用？</p><p>如果配合上P就有意思了，P是一直在震荡，这一直是有速度的，但如果把这个速度进行反向，比如正在向上运动的时候会有向上的速度，那加到一起输出会产生抑制的效果。那也就是说是D控制的是停止，这样就可以让P不再震荡。</p><p>注意如果$K_D$这个值过大，也会出现震荡的现象，但也别太小，效果不明显了。</p><p>代码里面很好写，就是用当前的输入减去上一时刻的输入，这样就模拟了一种微分状态。</p><h3 id="积分（I）"><a href="#积分（I）" class="headerlink" title="积分（I）"></a>积分（I）</h3><p>我是最后才说的积分部分，其实以上已经可以做到很好了，但还是有个缺点，就是无人机的升力和重力二力平衡的时候，无人机就不会再上升，如果你做过这个实验你会发现，它总是和目标值还差一点，但它就是不动了，为了解决这个问题就引入了积分。</p><p>还是这张图，假设无人机悬停在这里了。</p><p><img src="/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/2021-04-03_20-55-36.png" alt="2021-04-03_20-55-36"></p><p>积分主要积的是从开始到当前所有的输入值，写代码的时候就是一直累加。你可能有个问题，一直累加的话岂不是一直上升，那么开始的时候全是正数，那无人机就会一直上升，直到超过目标值的时候，偏差会变成负值，这样累加的时候这个值会变小，就开始下降。</p><p>这个值对应的参数不建议给特别大，小一点就好了，可以先把PD的参数调好之后再调这个参数。</p><hr><p>最后放一张调节的图，分别对应那几个变化情况。</p><p><img src="/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/20181216103811570.jpg" alt="20181216103811570"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PID控制算法可以说是我比较早听说的算法了，但几年前我并不太了解原理，我只能按照公式敲除代码，但经过考研之后，我的高数进一步提高，有些东西我逐渐看透了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/04/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%</summary>
      
    
    
    
    <category term="奇妙的原理" scheme="https://magic-matrix.gitee.io/categories/%E5%A5%87%E5%A6%99%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="原理" scheme="https://magic-matrix.gitee.io/tags/%E5%8E%9F%E7%90%86/"/>
    
    <category term="单片机" scheme="https://magic-matrix.gitee.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Python的全部内置方法</title>
    <link href="https://magic-matrix.gitee.io/2021/04/Python%E7%9A%84%E5%85%A8%E9%83%A8%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>https://magic-matrix.gitee.io/2021/04/Python%E7%9A%84%E5%85%A8%E9%83%A8%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-02T07:18:41.000Z</published>
    <updated>2021-10-14T06:59:54.285Z</updated>
    
    <content type="html"><![CDATA[<p>当用Python定义一个类的时候，其实有一些固定的方法，这些方法是固定的，当然程序员是可以根据自己的需求去更改。</p><p>每次我在使用这些方法的时候，我还需要去自己去查，很麻烦，因此我打算总结一套全部的内置方法。</p><h2 id="关于对象周期的方法"><a href="#关于对象周期的方法" class="headerlink" title="关于对象周期的方法"></a>关于对象周期的方法</h2><p>这部分其实主要就是构造方法和析构方法。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>__new__(cls,[...)</code></p><p>或许大部分人认为构造方法为<code>__init__()</code>，其实在这之前还有一个方法，这个方法在对象实例化的时候调用，而且比<code>__init__()</code>执行的时间还要早，但不经常用，除非特殊情况。</p></li><li><p><code>__init__(self,[...])</code></p><p>这就很常见了，一般用作初始化，注意，形参的参数是决定实例化的时候传进来的参数，所以这很重要，一般都会自己去重写。</p></li></ul><h3 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h3><ul><li><p><code>__del__(self)</code></p><p>主要是在销毁的时候会调用这个方法，但是需要注意的是，当Python解释器退出但对象仍然存活的时候， <code>__del__</code>()并不会 执行。 所以养成一个手工清理的好习惯是很重要的，比如及时关闭连接。</p></li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>有些方法可以根据操作符执行，利用好的话可以玩出很多花样。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li><p><code>__cmp__(self, other)</code></p><p>它上定义了所有比较操作符的行为（&lt;,==,!=,等等），当使用这些运算符的时候就会调用，但其实并不常用，因为不方便，不能判断使用的是哪种运算符。</p></li><li><p><code>__eq__(self, other)</code></p><p>定义等于操作符(==)的行为。</p></li><li><p><code>__ne__(self, other)</code></p><p>定义不等于操作符(!=)的行为。</p></li><li><p><code>__lt__(self, other)</code></p><p>定义小于操作符(&lt;)的行为。</p></li><li><p><code>__gt__(self, other)</code></p><p>定义大于操作符(&gt;)的行为。</p></li><li><p><code>__le__(self, other)</code></p><p>定义小于等于操作符(&lt;)的行为。</p></li><li><p><code>__ge__(self, other)</code></p><p>定义大于等于操作符(&gt;)的行为。</p></li></ul><h3 id="数值操作符"><a href="#数值操作符" class="headerlink" title="数值操作符"></a>数值操作符</h3><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><p>一元操作符只有一个操作符。</p><ul><li><p><code>__pos__(self)</code></p><p>实现取正操作，例如 +some_object。</p></li><li><p><code>__neg__(self)</code></p><p>实现取负操作，例如 -some_object。</p></li><li><p><code>__abs__(self)</code></p><p>实现内建绝对值函数 abs() 操作。</p></li><li><p><code>__invert__(self)</code></p><p>实现取反操作符 ~。</p></li><li><p><code>__round__(self， n)</code></p><p>实现内建函数 round() ，n 是近似小数点的位数。</p></li><li><p><code>__floor__(self)</code></p><p>实现 <code>math.floor()</code> 函数，即向下取整。</p></li><li><p><code>__ceil__(self)</code></p><p>实现 <code>math.ceil()</code> 函数，即向上取整。</p></li><li><p><code>__trunc__(self)</code></p><p>实现 <code>math.trunc()</code> 函数，即距离零最近的整数。</p></li></ul><h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><p>也就是基本的算数运算符。</p><ul><li><p><code>__add__(self, other)</code></p><p>实现加法操作。</p></li><li><p><code>__sub__(self, other)</code></p><p>实现减法操作。</p></li><li><p><code>__mul__(self, other)</code></p><p>实现乘法操作。</p></li><li><p><code>__floordiv__(self, other)</code></p><p>实现使用 // 操作符的整数除法。</p></li><li><p><code>__div__(self, other)</code></p><p>实现使用 / 操作符的除法。</p></li><li><p><code>__truediv__(self, other)</code></p><p>实现 <code>_true_</code> 除法，这个函数只有使用<code>from __future__ import division</code>时才有作用。</p></li><li><p><code>__mod__(self, other)</code></p><p>实现 % 取余操作。</p></li><li><p><code>__divmod__(self, other)</code></p><p>实现 <code>divmod</code> 内建函数。</p></li><li><p><code>__pow__</code></p><p>实现 ** 操作符。</p></li><li><p><code>__lshift__(self, other)</code></p><p>实现左移位运算符 &lt;&lt; 。</p></li><li><p><code>__rshift__(self, other)</code></p><p>实现右移位运算符 &gt;&gt; 。</p></li><li><p><code>__and__(self, other)</code></p><p>实现按位与运算符 &amp; 。</p></li><li><p><code>__or__(self, other)</code></p><p>实现按位或运算符 | 。</p></li><li><p><code>__xor__(self, other)</code></p><p>实现按位异或运算符 ^ 。</p></li></ul><h4 id="反射运算符"><a href="#反射运算符" class="headerlink" title="反射运算符"></a>反射运算符</h4><ul><li><p><code>radd__(self, other)</code></p><p>实现反射加法操作。</p></li><li><p><code>rsub__(self, other)</code></p><p>实现反射减法操作。</p></li><li><p><code>rmul__(self, other)</code></p><p>实现反射乘法操作。</p></li><li><p><code>rfloordiv__(self, other)</code></p><p>实现使用 // 操作符的整数反射除法。</p></li><li><p><code>rdiv__(self, other)</code></p><p>实现使用 / 操作符的反射除法。</p></li><li><p><code>rtruediv__(self, other)</code></p><p>实现 <code>_true_</code> 反射除法，这个函数只有使用 <code>from __future__ import division</code> 时才有作用。</p></li><li><p><code>rmod__(self, other)</code></p><p>实现 % 反射取余操作符。</p></li><li><p><code>rdivmod__(self, other)</code></p><p>实现调用 <code>divmod(other, self)</code> 时 <code>divmod</code> 内建函数的操作。</p></li><li><p><code>rpow__(self, other)</code></p><p>实现 ** 反射操作符。</p></li><li><p><code>rlshift__(self, other)</code></p><p>实现反射左移位运算符 &lt;&lt; 的作用。</p></li><li><p><code>rshift__(self, other)</code></p><p>实现反射右移位运算符 &gt;&gt; 的作用。</p></li><li><p><code>rand__(self, other)</code></p><p>实现反射按位与运算符 &amp; 。</p></li><li><p><code>ror__(self, other)</code></p><p>实现反射按位或运算符 | 。</p></li><li><p><code>rxor__(self, other)</code></p><p>实现反射按位异或运算符 ^ 。</p></li></ul><h4 id="增强赋值运算符"><a href="#增强赋值运算符" class="headerlink" title="增强赋值运算符"></a>增强赋值运算符</h4><ul><li><p><code>__iadd__(self, other)</code></p><p>实现加法赋值操作。</p></li><li><p><code>__isub__(self, other)</code></p><p>实现减法赋值操作。</p></li><li><p><code>__imul__(self, other)</code></p><p>实现乘法赋值操作。</p></li><li><p><code>__ifloordiv__(self, other)</code></p><p>实现使用 //= 操作符的整数除法赋值操作。</p></li><li><p><code>__idiv__(self, other)</code></p><p>实现使用 /= 操作符的除法赋值操作。</p></li><li><p><code>__itruediv__(self, other)</code></p><p>实现 <code>_true_</code> 除法赋值操作，这个函数只有使用 <code>from __future__ import division</code> 时才有作用。</p></li><li><p><code>__imod__(self, other)</code></p><p>实现 %= 取余赋值操作。</p></li><li><p><code>__ipow__(self, other)</code></p><p>实现 **= 操作。</p></li><li><p><code>__ilshift__(self, other)</code></p><p>实现左移位赋值运算符 &lt;&lt;= 。</p></li><li><p><code>__irshift__(self, other)</code></p><p>实现右移位赋值运算符 &gt;&gt;= 。</p></li><li><p><code>__iand__(self, other)</code></p><p>实现按位与运算符 &amp;= 。</p></li><li><p><code>__ior__(self, other)</code></p><p>实现按位或赋值运算符 | 。</p></li><li><p><code>__ixor__(self, other)</code></p><p>实现按位异或赋值运算符 ^= 。</p></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p><code>__int__(self)</code></p><p>实现到<code>int</code>的类型转换。</p></li><li><p><code>__long__(self)</code></p><p>实现到long的类型转换。</p></li><li><p><code>__float__(self)</code></p><p>实现到float的类型转换。</p></li><li><p><code>__complex__(self)</code></p><p>实现到complex的类型转换。</p></li><li><p><code>__oct__(self)</code></p><p>实现到八进制数的类型转换。</p></li><li><p><code>__hex__(self)</code></p><p>实现到十六进制数的类型转换。</p></li><li><p><code>__index__(self)</code></p><p>实现当对象用于切片表达式时到一个整数的类型转换。如果你定义了一个可能会用于切片操作的数值类型，你应该定义 <code>__index__</code>。</p></li><li><p><code>__trunc__(self)</code></p><p>当调用 <code>math.trunc(self)</code> 时调用该方法， <code>__trunc__</code> 应该返回 self 截取到一个整数类型（通常是long类型）的值。</p></li><li><p><code>__coerce__(self)</code></p><p>该方法用于实现混合模式算数运算，如果不能进行类型转换， <code>__coerce__</code>应该返回 None 。反之，它应该返回一个二元组 self 和 other ，这两者均已被转换成相同的类型。</p></li></ul><h2 id="类的表示"><a href="#类的表示" class="headerlink" title="类的表示"></a>类的表示</h2><ul><li><p><code>__str__(self)</code></p><p>定义对类的实例调用 <code>str()</code> 时的行为。</p></li><li><p><code>__repr__(self)</code></p><p>定义对类的实例调用 <code>repr()</code> 时的行为。<code>str()</code> 和 <code>repr()</code> 最主要的差别在于“目标用户”。 <code>repr()</code> 的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的Python代码），而 <code>str()</code> 则产生人类可读的输出。</p></li><li><p><code>__unicode__(self)</code></p><p>定义对类的实例调用 <code>unicode()</code> 时的行为。 <code>unicode()</code> 和 <code>str()</code> 很像，只是它返回unicode字符串。注意，如果调用者试图调用 <code>str()</code> 而你的类只实现了 <code>__unicode__()</code> ，那么类将不能正常工作。所有你应该总是定义 <code>__str__()</code> ，以防有些人没有闲情雅致来使用unicode。</p></li><li><p><code>__format__(self)</code></p><p>定义当类的实例用于新式字符串格式化时的行为，例如， <code>&quot;Hello, 0:abc!&quot;.format(a)</code>会导致调用 <code>a.__format__(&quot;abc&quot;)</code> 。当定义你自己的数值类型或字符串类型时，你可能想提供某些特殊的格式化选项，这种情况下这个方法会非常有用。</p></li><li><p><code>__hash__(self)</code></p><p>定义对类的实例调用 <code>hash()</code> 时的行为。它必须返回一个整数，其结果会被用于字典中键的快速比较。同时注意一点，实现这个方法通常也需要实现 <code>__eq__</code> ，并且遵守如下的规则： <code>a == b</code> 意味着 <code>hash(a) == hash(b)</code>。</p></li><li><p><code>__nonzero__(self)</code></p><p>定义对类的实例调用 <code>bool()</code> 时的行为，根据你自己对类的设计，针对不同的实例，这个方法应该相应地返回True或False。</p></li><li><p><code>__dir__(self)</code></p><p>定义对类的实例调用 <code>dir()</code> 时的行为，这个方法应该向调用者返回一个属性列表。一般来说，没必要自己实现 <code>__dir__</code>。</p></li></ul><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul><li><p><code>__getattr__(self, name)</code></p><p>当用户试图访问一个根本不存在（或者暂时不存在）的属性时，你可以通过这个魔法方法来定义类的行为。这个可以用于捕捉错误的拼写并且给出指引，使用废弃属性时给出警告（如果你愿意，仍然可以计算并且返回该属性），以及灵活地处理AttributeError。只有当试图访问不存在的属性时它才会被调用，所以这不能算是一个真正的封装的办法。</p></li><li><p><code>__setattr__(self, name, value)</code></p><p>和 <code>__getattr__</code> 不同， <code>__setattr__</code> 可以用于真正意义上的封装。它允许你自定义某个属性的赋值行为，不管这个属性存在与否，也就是说你可以对任意属性的任何变化都定义自己的规则。然后，一定要小心使用 <code>__setattr__</code> ，这个列表最后的例子中会有所展示。</p></li><li><p><code>__delattr__(self, name)</code></p><p>这个魔法方法和 <code>__setattr__</code> 几乎相同，只不过它是用于处理删除属性时的行为。和 <code>__setattr__</code> 一样，使用它时也需要多加小心，防止产生无限递归（在  <code>__delattr__</code> 的实现中调用 <code>del self.name</code> 会导致无限递归）。</p></li><li><p><code>__getattribute__(self, name)</code></p><p> <code>__getattribute__</code> 看起来和上面那些方法很合得来，但是最好不要使用它。 <code>__getattribute__</code> 只能用于新式类。在最新版的Python中所有的类都是新式类，在老版Python中你可以通过继承 object 来创建新式类。 <code>__getattribute__</code> 允许你自定义属性被访问时的行为，它也同样可能遇到无限递归问题（通过调用基类的 <code>__getattribute__</code> 来避免）。 <code>__getattribute__</code> 基本上可以替代 <code>__getattr__</code> 。只有当它被实现，并且显式地被调用，或者产生 <code>AttributeError</code> 时它才被使用。 这个魔法方法可以被使用（毕竟，选择权在你自己），我不推荐你使用它，因为它的使用范围相对有限（通常我们想要在赋值时进行特殊操作，而不是取值时），而且实现这个方法很容易出现Bug。</p></li></ul><h2 id="自定义序列"><a href="#自定义序列" class="headerlink" title="自定义序列"></a>自定义序列</h2><p>有许多办法可以让你的Python类表现得像是内建序列类型（字典，元组，列表，字符串等）。</p><ul><li><p><code>__len__(self)</code></p><p>返回容器的长度，可变和不可变类型都需要实现。</p></li><li><p><code>__getitem__(self, key)</code></p><p>定义对容器中某一项使用 <code>self[key]</code> 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 <code>TypeError</code> 异常，同时在没有与键值相匹配的内容时产生 <code>KeyError</code> 异常。</p></li><li><p><code>__setitem__(self, key)</code></p><p>定义对容器中某一项使用 <code>self[key]</code> 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 <code>KeyError</code> 和 <code>TypeError</code> 异常。  <code>__iter__(self, key)</code> 它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用 <code>iter()</code> 函数调用，以及在类似 <code>for x in container:</code>的循环中被调用。迭代器是他们自己的对象，需要定义 <code>__iter__</code> 方法并在其中返回自己。</p></li><li><p><code>__reversed__(self)</code></p><p>定义了对容器使用 <code>reversed()</code> 内建函数时的行为。它应该返回一个反转之后的序列。当你的序列类是有序时，类似列表和元组，再实现这个方法。</p></li><li><p><code>__contains__(self, item)</code></p><p><code>__contains__</code> 定义了使用 <code>in</code> 和  <code>not in</code> 进行成员测试时类的行为。你可能好奇为什么这个方法不是序列协议的一部分，原因是，如果<code>__contains__</code> 没有定义，Python就会迭代整个序列，如果找到了需要的一项就返回 True 。</p></li><li><p><code>__missing__(self ,key)</code></p><p><code>__missing__</code> 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， <code>&quot;george&quot;</code> 不是字典中的一个键，当试图访问 <code>d[&quot;george&quot;]</code> 时就会调用 <code>d.__missing__(&quot;george&quot;)</code> ）。</p></li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul><li><p><code>__instancecheck__(self, instance)</code></p><p>检查一个实例是否是你定义的类的一个实例（例如 <code>isinstance(instance, class)</code> ）。</p></li><li><p><code>__subclasscheck__(self, subclass)</code></p><p>检查一个类是否是你定义的类的子类（例如 <code>issubclass(subclass, class)</code> ）。</p></li></ul><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><ul><li><p><code>__call__(self, [args...])</code></p><p>允许类的一个实例像函数那样被调用。本质上这代表了 <code>x()</code> 和 <code>x.__call__()</code> 是相同的。注意 <code>__call__</code> 可以有多个参数，这代表你可以像定义其他任何函数一样，定义 <code>__call__</code> ，喜欢用多少参数就用多少。</p></li></ul><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><ul><li><p><code>__enter__(self)</code></p><p>定义使用 <code>with</code> 声明创建的语句块最开始上下文管理器应该做些什么。注意 <code>__enter__</code> 的返回值会赋给 <code>with</code> 声明的目标，也就是 <code>as</code> 之后的东西。</p></li><li><p><code>__exit__(self, exception_type, exception_value, traceback)</code></p><p>定义当 <code>with</code> 声明语句块执行完毕（或终止）时上下文管理器的行为。它可以用来处理异常，进行清理，或者做其他应该在语句块结束之后立刻执行的工作。如果语句块顺利执行， <code>exception_type , exception_value</code> 和 <code>traceback</code> 会是 <code>None</code> 。否则，你可以选择处理这个异常或者让用户来处理。如果你想处理异常，确保 <code>__exit__</code> 在完成工作之后返回 <code>True</code> 。如果你不想处理异常，那就让它发生吧。</p></li></ul><h2 id="创建描述符对象"><a href="#创建描述符对象" class="headerlink" title="创建描述符对象"></a>创建描述符对象</h2><ul><li><p><code>__get__(self, instance, owner)</code></p><p>定义当试图取出描述符的值时的行为。 instance 是拥有者类的实例， owner 是拥有者类本身。</p></li><li><p><code>__set__(self, instance, owner)</code></p><p>定义当描述符的值改变时的行为。 instance 是拥有者类的实例， value 是要赋给描述符的值。</p></li><li><p><code>__delete__(self, instance, owner)</code></p><p>定义当描述符的值被删除时的行为。instance 是拥有者类的实例。</p></li></ul><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><ul><li><p><code>__copy__(self)</code></p><p>定义对类的实例使用 <code>copy.copy()</code> 时的行为。 <code>copy.copy()</code> 返回一个对象的浅拷贝，这意味着拷贝出的实例是全新的，然而里面的数据全都是引用的。也就是说，对象本身是拷贝的，但是它的数据还是引用的（所以浅拷贝中的数据更改会影响原对象）。</p></li><li><p><code>__deepcopy__(self, memodict=)</code></p><p>定义对类的实例使用 <code>copy.deepcopy()</code> 时的行为。 <code>copy.deepcopy()</code> 返回一个对象的深拷贝，这个对象和它的数据全都被拷贝了一份。 <code>memodict</code> 是一个先前拷贝对象的缓存，它优化了拷贝过程，而且可以防止拷贝递归数据结构时产生无限递归。当你想深拷贝一个单独的属性时，在那个属性上调用 <code>copy.deepcopy()</code>，使用 <code>memodict</code>作为第一个参数。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当用Python定义一个类的时候，其实有一些固定的方法，这些方法是固定的，当然程序员是可以根据自己的需求去更改。&lt;/p&gt;
&lt;p&gt;每次我在使用这些方法的时候，我还需要去自己去查，很麻烦，因此我打算总结一套全部的内置方法。&lt;/p&gt;
&lt;h2 id=&quot;关于对象周期的方法&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Matrix的笔记本" scheme="https://magic-matrix.gitee.io/categories/Matrix%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="python" scheme="https://magic-matrix.gitee.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Git的详细教程</title>
    <link href="https://magic-matrix.gitee.io/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
    <id>https://magic-matrix.gitee.io/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</id>
    <published>2021-03-11T10:47:57.000Z</published>
    <updated>2021-10-14T06:59:14.212Z</updated>
    
    <content type="html"><![CDATA[<p>是时候整理一下Git命令了，以前总是单独去使用，太不方便了，这次我就直接整理一份，方便以后直接使用。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/duitang.jpeg" alt="duitang"></p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p><code>Git</code> 是<strong>程序员</strong>学习和工作都离不开发工具，也是<strong>非程序员</strong>好用的文档版本管理工具。</p><p><code>Git</code> 是一种分布式版本控制系统，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 <code>Git</code> 来做自己的文档版本管理工具。</p><p><code>Git</code> 的api很多，但其实平时项目中90%的需求都只需要用到几个基本的功能即可，所以本文将从 <code>实用主义</code> 和 <code>深入探索</code> 2个方面去谈谈如何在项目中使用 <code>Git</code>，一般来说，看完 <code>实用主义</code> 这一节就可以开始在项目中动手用。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>先大概看一下，我整理了什么命令：</p><ul><li><code>git clone</code></li><li><code>git config</code></li><li><code>git branch</code></li><li><code>git checkout</code></li><li><code>git status</code></li><li><code>git add</code></li><li><code>git commit</code></li><li><code>git push</code></li><li><code>git pull</code></li><li><code>git log</code></li><li><code>git tag</code></li></ul><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><blockquote><p>从git服务器拉取代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gafish&#x2F;gafish.github.com.git</span><br></pre></td></tr></table></figure><p>代码下载完成后在当前文件夹中会有一个 <code>gafish.github.com</code> 的目录，通过 <code>cd gafish.github.com</code> 命令进入目录。</p><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><blockquote><p>配置开发者用户名和邮箱</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name gafish</span><br><span class="line">git config user.email gafish@qqqq.com</span><br></pre></td></tr></table></figure><p>每次代码提交的时候都会生成一条提交记录，其中会包含当前配置的用户名和邮箱。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><blockquote><p>创建、重命名、查看、删除项目分支，通过 <code>Git</code> 做项目开发时，一般都是在开发分支中进行，开发完成后合并分支到主干。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch daily&#x2F;0.0.0</span><br></pre></td></tr></table></figure><p>创建一个名为 <code>daily/0.0.0</code> 的日常开发分支，分支名只要不包括特殊字符即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m daily&#x2F;0.0.0 daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>如果觉得之前的分支名不合适，可以为新建的分支重命名，重命名分支名为 <code>daily/0.0.1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>通过不带参数的branch命令可以查看当前项目分支列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>如果分支已经完成使命则可以通过 <code>-d</code> 参数将分支删除，这里为了继续下一步操作，暂不执行删除操作。</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><blockquote><p>切换分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>切换到 <code>daily/0.0.1</code> 分支，后续的操作将在这个分支上进行。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><blockquote><p>查看文件变动状态</p></blockquote><p>通过任何你喜欢的编辑器对项目中的 <code>README.md</code> 文件做一些改动，保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>通过 <code>git status</code> 命令可以看到文件当前状态 <code>Changes not staged for commit:</code> （<em>改动文件未提交到暂存区</em>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">On branch daily&#x2F;0.0.1</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    modified:   README.md</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><blockquote><p>添加文件变动到暂存区</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure><p>通过指定文件名 <code>README.md</code> 可以将该文件添加到暂存区，如果想添加所有文件可用 <code>git add .</code> 命令，这时候可通过 <code>git status</code> 看到文件当前状态 <code>Changes to be committed:</code> （<em>文件已提交到暂存区</em>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">On branch daily&#x2F;0.0.1</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><blockquote><p>提交文件变动到版本库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#39;这里写提交原因&#39;</span><br></pre></td></tr></table></figure><p>通过 <code>-m</code> 参数可直接在命令行里输入提交描述文本。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><blockquote><p>将本地的代码改动推送到服务器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p><code>origin</code> 指代的是当前的git服务器地址，这行命令的意思是把 <code>daily/0.0.1</code> 分支推送到服务器，当看到命令行返回如下字符表示推送成功了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">Writing objects: 100% (3&#x2F;3), 267 bytes | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1&#x2F;1), completed with 1 local objects.</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;gafish&#x2F;gafish.github.com.git</span><br><span class="line"> * [new branch]      daily&#x2F;0.0.1 -&gt; daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>现在我们回到Github网站的项目首页，点击 <code>Branch:master</code> 下拉按钮，就会看到刚才推送的 <code>daily/00.1</code> 分支了。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><blockquote><p>将服务器上的最新代码拉取到本地</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>如果其它项目成员对项目做了改动并推送到服务器，我们需要将最新的改动更新到本地，这里我们来模拟一下这种情况。</p><p>进入Github网站的项目首页，再进入 <code>daily/0.0.1</code> 分支，在线对 <code>README.md</code> 文件做一些修改并保存，然后在命令中执行以上命令，它将把刚才在线修改的部分拉取到本地，用编辑器打开 <code>README.md</code> ，你会发现文件已经跟线上的内容同步了。</p><p><em>如果线上代码做了变动，而你本地的代码也有变动，拉取的代码就有可能会跟你本地的改动冲突，一般情况下 <code>Git</code> 会自动处理这种冲突合并，但如果改动的是同一行，那就需要手动来合并代码，编辑文件，保存最新的改动，再通过 <code>git add .</code> 和 <code>git commit -m &#39;xxx&#39;</code>来提交合并。</em></p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><blockquote><p>查看版本提交记录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>通过以上命令，我们可以查看整个项目的版本提交记录，它里面包含了<code>提交人</code>、<code>日期</code>、<code>提交原因</code>等信息，得到的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit c334730f8dba5096c54c8ac04fdc2b31ede7107a</span><br><span class="line">Author: gafish &lt;gafish@qqqq.com&gt;</span><br><span class="line">Date:   Wed Jan 11 09:44:13 2017 +0800</span><br><span class="line">    Update README.md</span><br><span class="line">commit ba6e3d21fcb1c87a718d2a73cdd11261eb672b2a</span><br><span class="line">Author: gafish &lt;gafish@qqqq.com&gt;</span><br><span class="line">Date:   Wed Jan 11 09:31:33 2017 +0800</span><br><span class="line">    test</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>提交记录可能会非常多，按 <code>J</code> 键往下翻，按 <code>K</code> 键往上翻，按 <code>Q</code> 键退出查看。</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><blockquote><p>为项目标记里程碑</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag publish&#x2F;0.0.1</span><br><span class="line">git push origin publish&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>当我们完成某个功能需求准备发布上线时，应该将此次完整的项目代码做个标记，并将这个标记好的版本发布到线上，这里我们以 <code>publish/0.0.1</code> 为标记名并发布，当看到命令行返回如下内容则表示发布成功了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;gafish&#x2F;gafish.github.com.git</span><br><span class="line"> * [new tag]         publish&#x2F;0.0.1 -&gt; publish&#x2F;0.0.1</span><br></pre></td></tr></table></figure><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><blockquote><p>设置哪些内容不需要推送到服务器，这是一个配置文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p><code>.gitignore</code> 不是 <code>Git</code> 命令，而在项目中的一个文件，通过设置 <code>.gitignore</code> 的内容告诉 <code>Git</code> 哪些文件应该被忽略不需要推送到服务器，通过以上命令可以创建一个 <code>.gitignore</code> 文件，并在编辑器中打开文件，每一行代表一个要忽略的文件或目录，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.html</span><br><span class="line">build&#x2F;</span><br></pre></td></tr></table></figure><p>以上内容的意思是 <code>Git</code> 将忽略 <code>demo.html</code> 文件 和 <code>build/</code> 目录，这些内容不会被推送到服务器上。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（<em>Working Directory</em>）</h3><p>就是你在电脑里能看到的目录，比如上文中的 <code>gafish.github.com</code>文件夹就是一个工作区。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/1.webp" alt="1"></p><h3 id="本地版本库（Local-Repository）"><a href="#本地版本库（Local-Repository）" class="headerlink" title="本地版本库（Local Repository）"></a>本地版本库（<em>Local Repository</em>）</h3><p>工作区有一个隐藏目录 <code>.git</code>，这个不算工作区，而是 <code>Git</code> 的版本库。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/2.webp" alt="2"></p><h3 id="暂存区（stage）"><a href="#暂存区（stage）" class="headerlink" title="暂存区（stage）"></a>暂存区（<em>stage</em>）</h3><p>本地版本库里存了很多东西，其中最重要的就是称为 <code>stage</code>（或者叫index）的暂存区，还有 <code>Git</code> 为我们自动创建的第一个分支<code>master</code>，以及指向 <code>master</code> 的一个指针叫 <code>HEAD</code>。</p><h3 id="远程版本库（Remote-Repository）"><a href="#远程版本库（Remote-Repository）" class="headerlink" title="远程版本库（Remote Repository）"></a>远程版本库（<em>Remote Repository</em>）</h3><p>一般指的是 <code>Git</code> 服务器上所对应的仓库，本文的示例所在的<code>github</code>仓库就是一个远程版本库。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/3.webp" alt="3"></p><h3 id="以上概念之间的关系"><a href="#以上概念之间的关系" class="headerlink" title="以上概念之间的关系"></a>以上概念之间的关系</h3><p><code>工作区</code>、<code>暂存区</code>、<code>本地版本库</code>、<code>远程版本库</code>之间几个常用的 <code>Git</code>操作流程如下图所示：</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/4.webp" alt="4"></p><h3 id="分支（Branch）"><a href="#分支（Branch）" class="headerlink" title="分支（Branch）"></a>分支（<em>Branch</em>）</h3><p>分支是为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/5.webp" alt="5"></p><h3 id="主分支（Master）"><a href="#主分支（Master）" class="headerlink" title="主分支（Master）"></a>主分支（<em>Master</em>）</h3><p>前面提到过 <code>master</code> 是 <code>Git</code> 为我们自动创建的第一个分支，也叫主分支，其它分支开发完成后都要合并到 <code>master</code>。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/6.webp" alt="6"></p><h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（<em>Tag</em>）</h3><p>标签是用于标记特定的点或提交的历史，通常会用来标记发布版本的名称或版本号（如：<code>publish/0.0.1</code>），虽然标签看起来有点像分支，但打上标签的提交是固定的，不能随意的改动，参见上图中的<code>1.0</code> / <code>2.0</code> / <code>3.0</code>。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p><code>HEAD</code> 指向的就是当前分支的最新提交。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/7.webp" alt="7"></p><p>以上概念了解的差不多，那就可以继续往下看，下面将以具体的操作类型来讲解 <code>Git</code> 的高阶用法。</p><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="git-add-1"><a href="#git-add-1" class="headerlink" title="git add"></a>git add</h3><blockquote><p>“</p><p>添加文件到暂存区</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure><p>通过此命令将打开交互式子命令系统，你将看到如下子命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***Commands***</span><br><span class="line">  1: status      2: update      3: revert      4: add untracked</span><br><span class="line">  5: patch      6: diff      7: quit      8: help</span><br></pre></td></tr></table></figure><p>通过输入序列号或首字母可以选择相应的功能，具体的功能解释如下：</p><ul><li><code>status</code>：功能上和 <code>git add -i</code> 相似，没什么鸟用</li><li><code>update</code>：详见下方 <code>git add -u</code></li><li><code>revert</code>：把已经添加到暂存区的文件从暂存区剔除，其操作方式和 <code>update</code> 类似</li><li><code>add untracked</code>：可以把新增的文件添加到暂存区，其操作方式和 <code>update</code> 类似</li><li><code>patch</code>：详见下方 <code>git add -p</code></li><li><code>diff</code>：比较暂存区文件和本地版本库的差异，其操作方式和 <code>update</code> 类似</li><li><code>quit</code>：退出 <code>git add -i</code> 命令系统</li><li><code>help</code>：查看帮助信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure><p>直接进入交互命令中最有用的 <code>patch</code> 模式</p><p>这是交互命令中最有用的模式，其操作方式和 <code>update</code> 类似，选择后<code>Git</code> 会显示这些文件的当前内容与本地版本库中的差异，然后您可以自己决定是否添加这些修改到暂存区，在命令行 <code>Stage deletion [y,n,q,a,d,/,?]?</code> 后输入 <code>y,n,q,a,d,/,?</code> 其中一项选择操作方式，具体功能解释如下：</p><ul><li>y：接受修改</li><li>n：忽略修改</li><li>q：退出当前命令</li><li>a：添加修改</li><li>d：放弃修改</li><li>/：通过正则表达式匹配修改内容</li><li>?：查看帮助信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u</span><br></pre></td></tr></table></figure><p>直接进入交互命令中的 <code>update</code> 模式</p><p>它会先列出工作区 <code>修改</code> 或 <code>删除</code> 的文件列表，<code>新增</code> 的文件不会被显示，在命令行 <code>Update&gt;&gt;</code> 后输入相应的列表序列号表示选中该项，回车继续选择，如果已选好，直接回车回到命令主界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --ignore-removal .</span><br></pre></td></tr></table></figure><p>添加工作区 <code>修改</code> 或 <code>新增</code> 的文件列表， <code>删除</code> 的文件不会被添加。</p><h3 id="git-commit-1"><a href="#git-commit-1" class="headerlink" title="git commit"></a>git commit</h3><blockquote><p>把暂存区的文件提交到本地版本库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#39;第一行提交原因&#39;  -m &#39;第二行提交原因&#39;</span><br></pre></td></tr></table></figure><p>不打开编辑器，直接在命令行中输入多行提交原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am &#39;提交原因&#39;</span><br></pre></td></tr></table></figure><p>将工作区 <code>修改</code> 或 <code>删除</code> 的文件提交到本地版本库， <code>新增</code> 的文件不会被提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &#39;提交原因&#39;</span><br></pre></td></tr></table></figure><p>修改最新一条提交记录的提交原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -C HEAD</span><br></pre></td></tr></table></figure><p>将当前文件改动提交到 <code>HEAD</code> 或当前分支的历史ID。</p><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><blockquote><p>移动或重命名文件、目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv a.md b.md -f</span><br></pre></td></tr></table></figure><p>将 <code>a.md</code> 重命名为 <code>b.md</code> ，同时添加变动到暂存区，加 <code>-f</code> 参数可以强制重命名，相比用 <code>mv a.md b.md</code> 命令省去了 <code>git add</code> 操作。</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><blockquote><p>从工作区和暂存区移除文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm b.md</span><br></pre></td></tr></table></figure><p>从工作区和暂存区移除文件 <code>b.md</code> ，同时添加变动到暂存区，相比用<code>rm b.md</code> 命令省去了 <code>git add</code> 操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm src&#x2F; -r</span><br></pre></td></tr></table></figure><p>允许从工作区和暂存区移除目录。</p><h3 id="git-status-1"><a href="#git-status-1" class="headerlink" title="git status"></a>git status</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure><p>以简短方式查看工作区和暂存区文件状态，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M demo.html</span><br><span class="line">?? test.html</span><br><span class="line">git status --ignored</span><br></pre></td></tr></table></figure><p>查看工作区和暂存区文件状态，包括被忽略的文件。</p><h2 id="操作分支"><a href="#操作分支" class="headerlink" title="操作分支"></a>操作分支</h2><h3 id="git-branch-1"><a href="#git-branch-1" class="headerlink" title="git branch"></a>git branch</h3><blockquote><p>查看、创建、删除分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>查看本地版本库和远程版本库上的分支列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><p>查看远程版本库上的分支列表，加上 <code>-d</code> 参数可以删除远程版本库上的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D</span><br></pre></td></tr></table></figure><p>分支未提交到本地版本库前强制删除分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><p>查看带有最后提交id、最近提交原因等信息的本地版本库分支列表。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/8.webp" alt="8"></p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><blockquote><p>将其它分支合并到当前分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash</span><br></pre></td></tr></table></figure><p>将待合并分支上的 <code>commit</code> 合并成一个新的 <code>commit</code> 放入当前分支，适用于待合并分支的提交记录不需要保留的情况。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/9.gif" alt="9"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff</span><br></pre></td></tr></table></figure><p>默认情况下，<code>Git</code> 执行”<code>快进式合并</code>“（fast-farward merge），会直接将 <code>Master</code> 分支指向 <code>Develop</code> 分支，使用 <code>--no-ff</code> 参数后，会执行正常合并，在 <code>Master</code> 分支上生成一个新节点，保证版本演进更清晰。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/10.webp" alt="10"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-edit</span><br></pre></td></tr></table></figure><p>在没有冲突的情况下合并，不想手动编辑提交原因，而是用 <code>Git</code> 自动生成的类似 <code>Merge branch &#39;test&#39;</code> 的文字直接提交</p><h3 id="git-checkout-1"><a href="#git-checkout-1" class="headerlink" title="git checkout"></a>git checkout</h3><blockquote><p>“</p><p>切换分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>创建 <code>daily/0.0.1</code> 分支，同时切换到这个新创建的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD demo.html</span><br></pre></td></tr></table></figure><p>从本地版本库的 <code>HEAD</code>（也可以是提交ID、分支名、Tag名） 历史中检出 <code>demo.html</code> 覆盖当前工作区的文件，如果省略 <code>HEAD</code> 则是从暂存区检出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan new_branch</span><br></pre></td></tr></table></figure><p>这个命令会创建一个全新的，完全没有历史记录的新分支，但当前源分支上所有的最新文件都还在，真是强迫症患者的福音，但这个新分支必须做一次 <code>git commit</code> 操作后才会真正成为一个新分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -p other_branch</span><br></pre></td></tr></table></figure><p>这个命令主要用来比较两个分支间的差异内容，并提供交互式的界面来选择进一步的操作，这个命令不仅可以比较两个分支间的差异，还可以比较单个文件的差异。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><blockquote><p>“</p><p>在 <code>Git</code> 的栈中保存当前修改或删除的工作进度，当你在一个分支里做某项功能开发时，接到通知把昨天已经测试完没问题的代码发布到线上，但这时你已经在这个分支里加入了其它未提交的代码，这个时候就可以把这些未提交的代码存到栈里。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>将未提交的文件保存到Git栈中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>查看栈中保存的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash show stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>显示栈中其中一条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>移除栈中其中一条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>从Git栈中检出最新保存的一条记录，并将它从栈中移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>从Git栈中检出其中一条记录，但不从栈中移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash branch new_banch</span><br></pre></td></tr></table></figure><p>把当前栈中最近一次记录检出并创建一个新分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><p>清空栈里的所有记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash create</span><br></pre></td></tr></table></figure><p>为当前修改或删除的文件创建一个自定义的栈并返回一个ID，此时并未真正存储到栈里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash store xxxxxx</span><br></pre></td></tr></table></figure><p>将 <code>create</code> 方法里返回的ID放到 <code>store</code> 后面，此时在栈里真正创建了一个记录，但当前修改或删除的文件并未从工作区移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash create</span><br><span class="line">09eb9a97ad632d0825be1ece361936d1d0bdb5c7</span><br><span class="line">$ git stash store 09eb9a97ad632d0825be1ece361936d1d0bdb5c7</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: Created via &quot;git stash store&quot;.</span><br></pre></td></tr></table></figure><h2 id="操作历史"><a href="#操作历史" class="headerlink" title="操作历史"></a>操作历史</h2><h3 id="git-log-1"><a href="#git-log-1" class="headerlink" title="git log"></a>git log</h3><blockquote><p>显示提交历史记录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><p>显示带提交差异对比的历史记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log demo.html</span><br></pre></td></tr></table></figure><p>显示 <code>demo.html</code> 文件的历史记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --since&#x3D;&quot;2 weeks ago&quot;</span><br></pre></td></tr></table></figure><p>显示2周前开始到现在的历史记录，其它时间可以类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --before&#x3D;&quot;2 weeks ago&quot;</span><br></pre></td></tr></table></figure><p>显示截止到2周前的历史记录，其它时间可以类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -10</span><br></pre></td></tr></table></figure><p>显示最近10条历史记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log f5f630a..HEAD</span><br></pre></td></tr></table></figure><p>显示从提交ID <code>f5f630a</code> 到 <code>HEAD</code> 之间的记录，<code>HEAD</code> 可以为空或其它提交ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline</span><br></pre></td></tr></table></figure><p>在一行中输出简短的历史记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;format:&quot;%h&quot;</span><br></pre></td></tr></table></figure><p>格式化输出历史记录。</p><p><code>Git</code> 用各种 <code>placeholder</code> 来决定各种显示内容，我挑几个常用的显示如下：</p><ul><li>%H: commit hash</li><li>%h: 缩短的commit hash</li><li>%T: tree hash</li><li>%t: 缩短的 tree hash</li><li>%P: parent hashes</li><li>%p: 缩短的 parent hashes</li><li>%an: 作者名字</li><li>%aN: mailmap的作者名</li><li>%ae: 作者邮箱</li><li>%ad: 日期 (—date= 制定的格式)</li><li>%ar: 日期, 相对格式(1 day ago)</li><li>%cn: 提交者名字</li><li>%ce: 提交者 email</li><li>%cd: 提交日期 (—date= 制定的格式)</li><li>%cr: 提交日期, 相对格式(1 day ago)</li><li>%d: ref名称</li><li>%s: commit信息标题</li><li>%b: commit信息内容</li><li>%n: 换行</li></ul><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><blockquote><p>合并分支的一条或几条提交记录到当前分支末梢</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 170a305</span><br></pre></td></tr></table></figure><p>合并提交ID <code>170a305</code> 到当前分支末梢。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><blockquote><p>将当前的分支重设（reset）到指定的 <code>&lt;commit&gt;</code> 或者 <code>HEAD</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed &lt;commit&gt;</span><br></pre></td></tr></table></figure><p><code>--mixed</code> 是不带参数时的默认参数，它退回到某个版本，保留文件内容，回退提交历史。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>暂存区和工作区中的内容不作任何改变，仅仅把 <code>HEAD</code> 指向 <code>&lt;commit&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>自从 <code>&lt;commit&gt;</code> 以来在工作区中的任何改变都被丢弃，并把 <code>HEAD</code>指向 <code>&lt;commit&gt;</code>。</p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><blockquote><p>重新定义分支的版本库状态</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase branch_name</span><br></pre></td></tr></table></figure><p>合并分支，这跟 <code>merge</code> 很像，但还是有本质区别，看下图：</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/11.webp" alt="11"></p><p>合并过程中可能需要先解决冲突，然后执行 <code>git rebase --continue</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~~</span><br></pre></td></tr></table></figure><p>打开文本编辑器，将看到从 <code>HEAD</code> 到 <code>HEAD~~</code> 的提交如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pick 9a54fd4 添加commit的说明</span><br><span class="line">pick 0d4a808 添加pull的说明</span><br><span class="line"># Rebase 326fc9f..0d4a808 onto d286baa</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line">#  p, pick &#x3D; use commit</span><br><span class="line">#  r, reword &#x3D; use commit, but edit the commit message</span><br><span class="line">#  e, edit &#x3D; use commit, but stop for amending</span><br><span class="line">#  s, squash &#x3D; use commit, but meld into previous commit</span><br><span class="line">#  f, fixup &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line">#  x, exec &#x3D; run command (the rest of the line) using shell</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>将第一行的 <code>pick</code> 改成 <code>Commands</code> 中所列出来的命令，然后保存并退出，所对应的修改将会生效。如果移动提交记录的顺序，将改变历史记录中的排序。</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><blockquote><p>撤销某次操作，此次操作之前和之后的 <code>commit</code> 和 <code>history</code>都会保留，并且把这次撤销作为一次最新的提交</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>撤销前一次提交操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD --no-edit</span><br></pre></td></tr></table></figure><p>撤销前一次提交操作，并以默认的 <code>Revert &quot;xxx&quot;</code> 为提交原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert -n HEAD</span><br></pre></td></tr></table></figure><p>需要撤销多次操作的时候加 <code>-n</code> 参数，这样不会每次撤销操作都提交，而是等所有撤销都完成后一起提交。</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><blockquote><p>查看工作区、暂存区、本地版本库之间的文件差异，用一张图来解释</p></blockquote><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/12.webp" alt="12"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --stat</span><br></pre></td></tr></table></figure><p>通过 <code>--stat</code> 参数可以查看变更统计数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.md | 1 -</span><br><span class="line">1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p><code>reflog</code> 可以查看所有分支的所有操作记录（包括commit和reset的操作、已经被删除的commit记录，跟 <code>git log</code> 的区别在于它不能查看已经删除了的commit记录。</p><p><img src="/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/13.webp" alt="13"></p><h2 id="远程版本库连接"><a href="#远程版本库连接" class="headerlink" title="远程版本库连接"></a>远程版本库连接</h2><p>如果在GitHub项目初始化之前，文件已经存在于本地目录中，那可以在本地初始化本地版本库，再将本地版本库跟远程版本库连接起来。</p><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><blockquote><p>在本地目录内部会生成.git文件夹</p></blockquote><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>不带参数，列出已经存在的远程分支，加上 <code>-v</code> 列出详细信息，在每一个名字后面列出其远程url。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;gafish&#x2F;gafish.github.com.git</span><br></pre></td></tr></table></figure><p>添加一个新的远程仓库，指定一个名字，以便引用后面带的URL。</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><blockquote><p>将远程版本库的更新取回到本地版本库。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin daily&#x2F;0.0.1</span><br></pre></td></tr></table></figure><p>默认情况下，<code>git fetch</code> 取回所有分支的更新。如果只想取回特定分支的更新，可以指定分支名。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><blockquote><p>查看文件每行代码块的历史信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame -L 1,10 demo.html</span><br></pre></td></tr></table></figure><p>截取 <code>demo.html</code> 文件1-10行历史信息。</p><h3 id="git-bisect"><a href="#git-bisect" class="headerlink" title="git bisect"></a>git bisect</h3><blockquote><p>二分查找历史记录，排查BUG</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect start</span><br></pre></td></tr></table></figure><p>开始二分查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect bad</span><br></pre></td></tr></table></figure><p>标记当前二分提交ID为有问题的点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect good</span><br></pre></td></tr></table></figure><p>标记当前二分提交ID为没问题的点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect reset</span><br></pre></td></tr></table></figure><p>查到有问题的提交ID后回到原分支。</p><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><blockquote><p>通过 Git 子模块可以跟踪外部版本库，它允许在某一版本库中再存储另一版本库，并且能够保持2个版本库完全独立</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https:&#x2F;&#x2F;github.com&#x2F;gafish&#x2F;demo.git demo</span><br></pre></td></tr></table></figure><p>将 <code>demo</code> 仓库添加为子模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update demo</span><br></pre></td></tr></table></figure><p>更新子模块 <code>demo</code>。</p><h3 id="git-gc"><a href="#git-gc" class="headerlink" title="git gc"></a>git gc</h3><blockquote><p>运行Git的垃圾回收功能，清理冗余的历史快照</p></blockquote><h3 id="git-archive"><a href="#git-archive" class="headerlink" title="git archive"></a>git archive</h3><blockquote><p>将加了tag的某个版本打包提取</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git archive -v --format&#x3D;zip v0.1 &gt; v0.1.zip</span><br></pre></td></tr></table></figure><p><code>--format</code> 表示打包的格式，如 <code>zip</code>，<code>-v</code> 表示对应的tag名，后面跟的是tag名，如 <code>v0.1</code>。</p><hr><blockquote><p>以上的内容来自一位大佬的整理，我只不过转载了他的文章，原文章在这里：</p><p><a href="https://mp.weixin.qq.com/s/2eA7VfHDd0MRGz_YgVrbiw">https://mp.weixin.qq.com/s/2eA7VfHDd0MRGz_YgVrbiw</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;是时候整理一下Git命令了，以前总是单独去使用，太不方便了，这次我就直接整理一份，方便以后直接使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/03/Git%E7%9A%84%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/duitang.jpe</summary>
      
    
    
    
    <category term="Matrix的笔记本" scheme="https://magic-matrix.gitee.io/categories/Matrix%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="命令" scheme="https://magic-matrix.gitee.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>我的java学习笔记</title>
    <link href="https://magic-matrix.gitee.io/2021/03/%E6%88%91%E7%9A%84java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://magic-matrix.gitee.io/2021/03/%E6%88%91%E7%9A%84java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-04T13:25:51.000Z</published>
    <updated>2021-10-14T06:59:31.421Z</updated>
    
    <content type="html"><![CDATA[<p>这是我当初学习java时的一些笔记，这几天翻出来看了一下，感觉可以作为一些参考，由于当时我有C/C++的基础，所以学习的速度非常快，有些地方直接和C/C++进行了对比，所以在观看的时候最好有一些编程基础。</p><blockquote><p><em>语言只是算法的载体，会得再多，也仅仅是获得了一个又一个躯壳，真正称得上灵魂的是算法，一个没有灵魂的躯壳，只能算一个行尸走肉。</em></p></blockquote><h2 id="开始前的一些准备"><a href="#开始前的一些准备" class="headerlink" title="开始前的一些准备"></a>开始前的一些准备</h2><h3 id="Java的三大版本"><a href="#Java的三大版本" class="headerlink" title="Java的三大版本"></a>Java的三大版本</h3><ul><li>JavaSE：标准版（桌面应用程序，控制台开发）</li><li><del>JavaME：嵌入式开发（手机app）</del></li><li>JavaEE：企业开发</li></ul><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><ul><li>JDK：Java开发者工具（用来开发Java程序）</li><li>JRE：Java运行环境（可以运行Java的程序）</li><li>JVM：Java虚拟机（核心部分）</li></ul><h3 id="虚拟机机制"><a href="#虚拟机机制" class="headerlink" title="虚拟机机制"></a>虚拟机机制</h3><p><code>.java</code>文件编译成<code>.class</code>文件，在虚拟机（JVM）上运行，实现“一次编译处处运行”。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>C/C++是程序员手动回收内存，高效准确，但容易失误。</p><p>java自动垃圾回收，可以自动检测内存，虽然规避了失误，但不会非常高效。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>官网下载JDK，尽量使用稳定版本，推荐使用压缩包进行解压，之后再进行环境变量配置，在版本上可以更好的更换。</p><p>配置环境变量包括：<code>JDK\bin</code>和<code>JDK\jre\bin</code>。</p><p>检测方法，输入<code>java -version</code>会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_101&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_101-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><ol><li><p>建立<code>Test.java</code>文件，用来写代码。</p></li><li><p>写下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 打印后不会换行</span></span><br><span class="line">        System.out.print(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印后自动换行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，类的名字和文件名字要一致。</p></li><li><p>打开命令窗口，cd到目标文件的路径，输入以下指令进行编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br></pre></td></tr></table></figure><p>编译完之后就会出现一个名字相同的<code>.class</code>文件。</p></li><li><p>运行<code>Test.class</code>文件，需要输入以下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Test</span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2></li></ol><p>这一部分的特点是java的基础部分，大部分非常和C/C++类似，所以有点基础的话简单看看就基本了解。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>单行注释：同C/C++，<code>//注释内容</code></p></li><li><p>多行注释：同C/C++，<code>/*注释内容*/</code></p><p>文档注释：java特有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*类名</span></span><br><span class="line"><span class="comment">*描述</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> 作者名</span></span><br><span class="line"><span class="comment">*<span class="doctag">@version</span> 版本</span></span><br><span class="line"><span class="comment">*<span class="doctag">@since</span> jdk版本</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3></li></ul><p>不是强制，但更具有规范性。</p><ul><li>包名：所有字母小写。</li><li>类名、接口名：大驼峰命名。</li><li>变量名、方法名：小驼峰命名。</li><li>常量名：所有字母大写，多单词时用下划线分割。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>注：</strong>八种<strong>基本数据类型</strong>之外全是<strong>引用数据类型</strong>。</p><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li>整型<ul><li><code>byte</code>：1字节</li><li><code>short</code>：2字节</li><li><code>int</code>：4字节</li><li><code>long</code>：8字节</li></ul></li><li>浮点型<ul><li><code>float</code>：单精度（7位有效数字），4字节</li><li><code>double</code>：双精度（16位有效数字），8字节</li></ul></li><li>字符型：<code>char</code></li><li>布尔型：<code>boolean</code></li></ul><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ul><li>类</li><li>接口</li><li>数组</li></ul><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><code>String</code>类型</h4><p>引用类型的一种，当出现两个相同的内容时，会分配相同的内存。</p><p>可以使用“+”来进行拼接，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello &quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure><p>注：只要有一个String类型进行相加时，就会合并成字符串，但前面会进行直接计算。</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="基本转换"><a href="#基本转换" class="headerlink" title="基本转换"></a>基本转换</h4><p>(char、byte、short) —&gt; int —&gt; long —&gt; float —&gt; double</p><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">byte</span> temp = (<span class="keyword">byte</span>)number;</span><br></pre></td></tr></table></figure><p>虽然强制转换很不错，这种操作会出现溢出现象，而且只针对基本数据类型。</p><p>注：布尔类型不能转换成其他类型。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>数学运算符、赋值运算符、逻辑运算符、比较运算符、位运算符、三元运算符，这些操作和C/C++类似，不再赘述。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>条件语句、循环语句、特殊语句（break、continue、return），这些操作和C/C++类似，不再赘述。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><p>变量声明完就要初始化，这涉及到一些java运行机制，所以必须这样操作。但在声明数组的时候可以不用初始化，值得注意的是，java数组声明和C/C++有点不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个int数组</span></span><br><span class="line"><span class="keyword">int</span>[] num;</span><br><span class="line"><span class="keyword">int</span> num[];</span><br></pre></td></tr></table></figure><p>和C/C++不同点主要是可以把中括号直接放前面。</p><p>虽然可以不用初始化，但一般还是直接初始化，这里需要使用new关键字，new作用就是分配空间。</p><p>以下为动态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个int数组，并初始化</span></span><br><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>动态初始化不会进行赋值，所以初始化完后会是默认值，初始化同时需要说明数据类型和分配大小。</p><p>还有一种静态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个int数组，并初始化</span></span><br><span class="line"><span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>这种直接初始化并赋值，不用说明空间申请大小。</p><h4 id="内部方法和属性"><a href="#内部方法和属性" class="headerlink" title="内部方法和属性"></a>内部方法和属性</h4><p>每个数组提供了一个length属性，可以利用这个属性直接查看这个数组的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = num.length;</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>其实就是每个数组中的每个元素就是一个数组，这样可以进行不断的数组嵌套。</p><p>书写方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="keyword">int</span> num1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">int</span> num2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只定义第一个维度</span></span><br><span class="line"><span class="keyword">int</span> num3[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以不相同</span></span><br><span class="line"><span class="keyword">int</span> num2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h2><p>java是一个<strong>强</strong>面向对象的语言，比C++和Python还要强调对象的概念，这部分主要去讲面向对象的一些操作。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="写一个类"><a href="#写一个类" class="headerlink" title="写一个类"></a>写一个类</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">    <span class="comment">// 属性（成员变量）</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">boolean</span> sex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法（成员函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量是可以不用初始化的，因为有默认值。</p><p>新建文件，类和文件名相同。</p><h4 id="实例化一个类"><a href="#实例化一个类" class="headerlink" title="实例化一个类"></a>实例化一个类</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个Persion对象，并实例化</span></span><br><span class="line">Persion persion;</span><br><span class="line">persion = <span class="keyword">new</span> Persion();</span><br><span class="line"></span><br><span class="line"><span class="comment">//与上面相同</span></span><br><span class="line">Persion persion = <span class="keyword">new</span> Persion();</span><br></pre></td></tr></table></figure><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>不定义对象句柄，直接实例化，接着使用内部的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Persion().showName();</span><br></pre></td></tr></table></figure><p>特点就是只使用一次就可以，或者将其作为实参直接传递。</p><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><p>语法格式：修饰符 类型 属性名 = 初值</p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul><li><code>public</code>：公有，外部可以直接访问。</li><li><code>private</code>：私有，只能通过类的内部访问。</li></ul><h4 id="成员变量的两种方式"><a href="#成员变量的两种方式" class="headerlink" title="成员变量的两种方式"></a>成员变量的两种方式</h4><ul><li><p>实例变量：最普通的变量，类实例化之后才能使用</p></li><li><p>类变量：在中间加上<code>static</code>进行修饰，类不用实例化，直接通过<code>类名.属性</code>就可以使用，存在于静态域。</p><p><code>static</code>的方法只能访问<code>static</code>的变量，但普通方法可以访问<code>static</code>变量。</p></li></ul><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>完成某些功能的函数。</p><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>java的参数传递方式很有意思，准确来讲是<strong>值传递</strong>。</p><p>首先讲一下虚拟机的内存模型：</p><p>虚拟机中有栈（stack）、堆（heap）和方法区（method）：</p><ul><li>栈（stack）：保存了所有的基本数据类型和引用数据类型的地址。</li><li>堆（heap）：所有对象，引用数据类型的地址指向这里。</li><li>方法区（method）：所有class和static变量</li></ul><p>当使用基本数据类型的时候，由于值传递，直接是拷贝了数据放在栈中，函数结束的时候直接销毁。</p><p>当使用引用数据类型的时候，由于值传递，拷贝了这个引用类型的地址，所以放在栈中的是该对象的地址（也就是指针），那么接下来使用的时候该地址指向了原对象，这就很有意思了，直接变成了引用传递。</p><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>一个类中可以存在多个同名方法，前提是参数的个数不同或者类型不同。</p><h4 id="多参数传递"><a href="#多参数传递" class="headerlink" title="多参数传递"></a>多参数传递</h4><h5 id="使用数组传递可变参数"><a href="#使用数组传递可变参数" class="headerlink" title="使用数组传递可变参数"></a>使用数组传递可变参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">// 函数的内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">String str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">persion.show(str);</span><br></pre></td></tr></table></figure><h5 id="使用java特有方式"><a href="#使用java特有方式" class="headerlink" title="使用java特有方式"></a>使用java特有方式</h5><p>其实和数组的使用方式相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line"><span class="comment">// 函数的内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">String str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">persion.show(str);</span><br><span class="line"><span class="comment">// 也可以这样用</span></span><br><span class="line">persion.show(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>第二种可以不写参数，但使用第一种的时候需要将null（空数组）传递进去。</li><li>必须放在最后，前面部分放其他类型。</li></ul><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>java没有命名空间的概念，但包的管理解决了命名冲突的问题，同时方便管理了其他的程序。</p><p>本质就是一个文件夹，文件夹中的每一个程序文件里最开始都有一句语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 顶层包名.子包名;</span><br></pre></td></tr></table></figure><p>这句指明该类所属的包，如果<strong>同一个包下调用文件</strong>可以不用说明。</p><p>比较常用的命名方式：</p><ul><li>小写，这样可以区分类文件</li><li>使用公司倒置命名，例如百度的域名：<code>www.baidu.com</code>，可以命名成<code>com.baidu.www</code></li></ul><p>调用的方式也很简单（上面的例子）：<code>import com.baidu.www.Demo</code></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="修饰符的区别"><a href="#修饰符的区别" class="headerlink" title="修饰符的区别"></a>修饰符的区别</h4><div class="table-container"><table><thead><tr><th>修饰符</th><th>类内部调用</th><th>同一包内调用</th><th>子类调用</th><th>其他地方</th></tr></thead><tbody><tr><td><code>private</code></td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>（缺省）</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td><code>protect</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td><code>public</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table></div><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造函数与类名相同，没有返回值，当实例化这个对象的时候就会调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Persion persion = <span class="keyword">new</span> Persion(<span class="number">18</span>,<span class="string">&quot;wang&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果定义了构造函数，就不会使用默认的构造函数。</p><p>同样道理，构造函数也存在重载，可以提供多种初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Persion persion = <span class="keyword">new</span> Persion(<span class="number">18</span>,<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">Persion persion = <span class="keyword">new</span> Persion(<span class="number">18</span>);</span><br><span class="line">Persion persion = <span class="keyword">new</span> Persion(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">Persion persion = <span class="keyword">new</span> Persion();</span><br></pre></td></tr></table></figure><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>表示当前对象，可以调用自己成员，主要是区分形参和类的成员变量的重名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以让<code>this()</code>为自己调用自己的构造函数，但必须有一个不用<code>this()</code>的构造函数。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">String school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>extends</code>继承了<code>Persion</code>类，拥有<code>Persion</code>类的所有成员。</p><p>注：不要仅为了一个功能去继承。</p><p>java只支持单继承，不允许多继承，允许多层继承。</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>方法重写可以更改从父类继承过来的函数，方便更好的使用。</p><p>要求：</p><ul><li>必须拥有相同的函数名、形参和返回值。</li><li>不能使用更严格的访问权限。</li><li>需要同时为<code>static</code>或非<code>static</code>。</li><li>子类抛出异常不能大于父类重写异常。</li></ul><p>理论上直接去重写就可以，加上<code>@Override</code>会更直观一点。</p><p>我使用的是idea，快捷键是<code>Ctrl + o</code>可以快速重写。</p><h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><p>作用：</p><ul><li>可以访问父类的属性。</li><li>可以调用父类的方法。</li><li>可以调用父类的构造方法。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>具体体现在重写（针对子类重写）和重载（重名）上。</p><h3 id="关键字static"><a href="#关键字static" class="headerlink" title="关键字static"></a>关键字<code>static</code></h3><p>只有通过<code>new</code>关键字才能实例化对象，关键字<code>static</code>修饰的变量或方法是类所有，实例化的对象可以共享此变量或方法。不想频繁修改或调用，就可以用<code>static</code>修饰的变量或方法，这样可以节省内存。</p><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a><code>instanceof</code>操作符</h4><p>检查一个对象是否是一个类型，如果是就返回<code>true</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查e是否是Persion类型</span></span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> Persion)&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a><code>Object</code>类</h4><p>是所有类的根父类（基类），即使没有继承，默认也继承基类。</p><p>如果想用一个对象作为形参，但不知道需要用什么数据类型时，可以使用<code>Object</code>类型，这样可以接受各种参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>子类可以直接转换父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Persion p = s;</span><br></pre></td></tr></table></figure><p>父类需要强制转换成子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Persion p = <span class="keyword">new</span> Persion();</span><br><span class="line">Student s = (Student) p;</span><br></pre></td></tr></table></figure><p>注：无继承关系不能转换。</p><h4 id="类比较大小"><a href="#类比较大小" class="headerlink" title="类比较大小"></a>类比较大小</h4><ul><li><p><code>==</code>运算符：比较的只是值，基本类型就是直接比较大小，引用类型比较的是引用<strong>指针</strong>，指向同一个对象的时候会返回<code>true</code>。</p></li><li><p><code>equals()</code>方法：继承了<code>Object</code>的类都具有这个方法，和<code>==</code>相同，也是指向对象的是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj1.equals(obj2);</span><br></pre></td></tr></table></figure><p>对File、String、Data以及包装类来说比较的是<strong>内容</strong>是否相等。</p></li></ul><p>字面量创建对象的时候，只会在常量池中引用其地址，而用<code>new</code>来分配内存创建对象的时候，会创建对象再考虑常量池。简单来讲字面量创建对象会节省内存。</p><p>默认状态下，<code>equals()</code>方法比较的是地址，当然也可以自己定义比较的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> day;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.year = year;</span><br><span class="line">        <span class="keyword">this</span>.month = month;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolen <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 检查是不是MyDate类型</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> MyDate)&#123;</span><br><span class="line">            MyDate md = (MyDate) obj;</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.year != md.year)</span><br><span class="line">                flag++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.month != md.month)</span><br><span class="line">                flag++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.day != md.day)</span><br><span class="line">                flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>这是对基本数据类型的封装，这样可以使用一些方法：</p><div class="table-container"><table><thead><tr><th style="text-align:center">基本数据类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center"><code>boolean</code></td><td style="text-align:center"><code>Boolean</code></td></tr><tr><td style="text-align:center"><code>byte</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center"><code>Short</code></td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>Integer</code></td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center"><code>Long</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>Character</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>Float</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>Double</code></td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 装箱</span></span><br><span class="line">Integer num2 = <span class="keyword">new</span> Integer(num);</span><br><span class="line"><span class="comment">// 拆箱</span></span><br><span class="line"><span class="keyword">int</span> num3 = num2.intValue();</span><br></pre></td></tr></table></figure><p>注：1.5版本后支持自动装箱和拆箱。</p><p>常用操作：类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="comment">// 数字转字符串</span></span><br><span class="line">String str = String.valueof(num1);</span><br></pre></td></tr></table></figure><h4 id="toString-的重写"><a href="#toString-的重写" class="headerlink" title=".toString()的重写"></a><code>.toString()</code>的重写</h4><p>默认情况下，会返回内存地址，重写可以修改返回内容。并可以直接用变量去返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Persion p = <span class="keyword">new</span> Persion();</span><br><span class="line"><span class="comment">// 以下两种情况一致</span></span><br><span class="line">System.out.print(p.toString());</span><br><span class="line">System.out.print(p);</span><br></pre></td></tr></table></figure><h4 id="初始化代码块"><a href="#初始化代码块" class="headerlink" title="初始化代码块"></a>初始化代码块</h4><p>下面的类包含了一个初始化代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">    <span class="comment">// 属性（成员变量）</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">boolean</span> sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 非静态初始化代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法（成员函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用就是对java对象进行初始化，执行顺序就是：声明成员变量的默认值，多个初始化块共同执行，执行构造函数。</p><p>初始化代码块可以拥有多个，执行顺序从上到下。</p><p>注：静态代码块在类被声明就开始执行，只执行一次</p><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a><code>final</code>关键字</h4><p>这个关键字可以让程序更加安全。</p><ul><li><code>final</code>标记的类不能被继承</li><li><code>final</code>标记的方法不能被重写</li><li><code>final</code>标记的变量只能赋值一次（常量，一般写成大写）</li></ul><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>针对于父类，不要去写具体方法，在接下来继承中主要有针对地去写。</p><p>用<code>abstract</code>修饰，可以修饰类和方法，含有抽象方法的类必须声明成抽象类。</p><p>抽象类不能实例化，只能作为父类被继承。</p><p>不能去修饰属性、私有方法、构造函数、静态方法、<code>final</code>标记的方法。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>java不支持多继承，所以可以使用接口来实现多继承的效果。</p><p>接口是抽象方法和常量值的集合，本质上是一种特殊的抽象类，只包含常量定义和方法定义，没有实现过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> NUM;</span><br><span class="line">    String STR;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类去继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>用<code>interface</code>来定义</li><li>默认<strong>成员变量</strong>全是<code>public static final</code>修饰</li><li>默认<strong>方法</strong>全是<code>public abstract</code>修饰</li><li>没有构造函数</li><li>采用多继承机制</li></ul><p>注：生成文件最好是接口文件。</p><p>类可以继承多个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span>,<span class="title">InterfaceC</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以继承接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> <span class="keyword">extends</span> <span class="title">InterfaceB</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：必须实现接口中所有的方法（重写），否则就是一个抽象类。</p><p>接口好处是，修改接口内容，抽象类会不稳定，如果我们新建一个接口，让类去多继承，可以避免这些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>,<span class="title">InterfaceB</span>,<span class="title">InterfaceC</span></span>&#123;</span><br><span class="line">    <span class="comment">// 继承了ClassA类</span></span><br><span class="line">    <span class="comment">// 实现了InterfaceA,InterfaceB,InterfaceC接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>顾名思义，类内定义一个类。</p><h2 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分"></a>其他部分</h2><p>这部分就比较零散，主要涉及到一些其他操作。</p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>public</code>：可以外部调用</li><li><code>static</code>：类方法</li><li><code>void</code>：无返回值</li><li><code>String[] args</code>：可以传递字符串数组</li></ul><p>在使用命令行运行的时候，可以在后面添加其他参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Test abc 123 jjj999</span><br></pre></td></tr></table></figure><p>后面部分会进入到<code>args</code>数组中，并且可以为接下来提供参数。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>程序运行难免会出现错误，一般出现异常就会直接停止程序。</p><p>异常分类：</p><ul><li><code>Error</code>：JVM内部错误，例如资源消耗严重。</li><li><code>Exception</code>：偶尔存在的外部错误，例如读取不存在的文件。</li></ul><h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 有可能发生异常部分</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// 遇到这种异常时的处理异常内容</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 最终会执行的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道捕获异常类型时，直接<code>Exception e</code>进行处理。</p><p>一些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接打印异常</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 返回异常内容</span></span><br><span class="line">e.getMessage();</span><br></pre></td></tr></table></figure><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 主动抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般是一个函数去主动抛出异常，如果遇到继承关系，子类重写时也需要抛出异常，但不能写范围小异常。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>存放于<code>java.util</code>包中，是存放变量的容器。</p><ul><li>集合只能存放对象，基本数据类型会转化为对应的封装类。</li><li>存放的方式为引用类型。</li><li>可以存放不同类型。</li><li>JDK5之后增加了泛型，可以记住对象中的数据类型。</li></ul><p>分类：</p><ul><li><code>Set</code>：无序，不可重复集合。</li><li><code>List</code>：有序，可重复集合。</li><li><code>Map</code>：具有映射关系集合。</li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><code>HashSet</code></h4><p>用Hash算法来存储集合中的元素，因此不能保证存储顺序，而且不能重复，不是线程安全。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Set s = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">// 等价于 Set&lt;Object&gt; set = new HashSet&lt;Object&gt;();</span></span><br><span class="line">        </span><br><span class="line">        s.add(obj);<span class="comment">// 添加对象</span></span><br><span class="line">        s.remove(obj);<span class="comment">// 移除对象</span></span><br><span class="line">        s.contains(obj);<span class="comment">// 判断是否有此对象</span></span><br><span class="line">        s.clear();<span class="comment">// 清空集合</span></span><br><span class="line">        s.size();<span class="comment">// 返回集合大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//迭代器遍历</span></span><br><span class="line">        Iterator it = s.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 每次循环判断是否有下一个</span></span><br><span class="line">            System.out.println(it.hasNext());</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj : set)&#123;</span><br><span class="line">            <span class="comment">// 把每个集合之中的元素遍历</span></span><br><span class="line">            <span class="comment">// 和C++类似</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用泛型</span></span><br><span class="line">        <span class="comment">// 这样只能存储单一的类型</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><code>TreeSet</code></h4><p>确保集合排序状态，默认情况下采用自然排序。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 大部分操作和HashSet一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><code>ArrayList</code></h4><p>有序的可重复的集合，每个元素都有对应的索引，默认顺序为添加顺序。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 大部分操作和HashSet一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><code>HashMap</code></h4><p>就是键值对，键不允许重复。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>); <span class="comment">// 添加一个键值对</span></span><br><span class="line">        map.get(<span class="string">&quot;a&quot;</span>);<span class="comment">// 通过键提取</span></span><br><span class="line">        map.remove(<span class="string">&quot;a&quot;</span>);<span class="comment">// 通过键移除</span></span><br><span class="line">        map.size();<span class="comment">// 返回大小</span></span><br><span class="line">        map.containsKey(<span class="string">&quot;a&quot;</span>);<span class="comment">// 判断是否有这个键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工具类：Collections"><a href="#工具类：Collections" class="headerlink" title="工具类：Collections"></a>工具类：<code>Collections</code></h4><p>主要提供一些有用的函数，这里不再赘述。</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>java泛型只在编译过程有效，编译后直接擦除对应的信息，不会到运行阶段。</p><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>具体使用和定义方法和C++类似。</p><p>定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T代表的是类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T代表的是类型</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">B</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>注：只能在函数内部使用。</p><p>静态方法不能使用类定义泛型，如果想使用，只能使用静态方法自己定义的泛型。</p><p>定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T代表的是类型</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        T t = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">set</span><span class="params">(T obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>使用一个<code>List</code>集合充当参数的时候，可以使用<code>?</code>充当通配符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>如果一个对象有限且固定，可以使用枚举来限制，例如：四季。</p><p>定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;1&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;2&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;3&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">season</span><span class="params">(String name, String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规定了构造函数只能使用自己定义的几个。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Season season = <span class="keyword">new</span> Season.SPRING;</span><br></pre></td></tr></table></figure><p>这样就可以单独返回规定的对象，而且获得的是相同对象（地址一样）。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>程序员可以在程序中嵌入信息，不会改变逻辑，会保存在name=value对中。</p><ul><li><code>@Override</code>：限定重写父方法，只能用于方法。</li><li><code>@Deprecated</code>：表示某个类或方法已过时。</li><li><code>@SupperWarning</code>：抑制编译器的警告。</li></ul><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><ul><li>文件流：基于文件的操作。</li><li>缓冲流：数据基于内存的操作。</li></ul><p>其他内容流懒得写了，看这<a href="https://www.runoob.com/java/java-files-io.html">网站</a>吧。</p><h2 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>程序：为了完成某个任务。</li><li>进程：正在运行的过程。</li><li>线程：进程细分成线程，一个程序的一条执行路径。</li></ul><h4 id="Thread实现多线程"><a href="#Thread实现多线程" class="headerlink" title="Thread实现多线程"></a>Thread实现多线程</h4><p>通过<code>java.lang.Thread</code>类来实现，每个线程通过Thread对象的<code>run()</code>来实现，通常把<code>run()</code>方法称作<strong>线程体</strong>。通过<code>start()</code>方法调用这个线程。</p><h5 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h5><ul><li><code>Thread()</code>：创建新的Thread对象。</li><li><code>Thread(String threadname)</code>：创建新的Thread对象，并指定名。</li><li><code>Thread(Runnable target)</code>：实现Runnable接口来创建线程目标对象。</li><li><code>Thread(Runnable target, String threadname)</code>：实现Runnable接口来创建线程目标对象，并指定名。</li></ul><p>方法一：</p><p>继承Thread类，重写<code>run()</code>，创建子对象的时候就表示创造了线程对象，调用<code>start()</code>方法的时候就可以启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程代码&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread t0 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>定义子类，实现Runnable接口，重写<code>run()</code>，使用Thread的构造方法来实现，此方法局限性更小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承Runnable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程代码&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun());</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>优先级为1~10，数字越大，优先级越高。默认设置优先级为5，</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul><li><code>start()</code>：启动线程</li><li><code>run()</code>：线程内容</li><li><code>getName()</code>：返回线程名称</li><li><code>setName()</code>：设置线程名称</li><li><code>static currentThread()</code>：返回当前线程</li><li><code>getPriority()</code>：获取优先级</li><li><code>setPriority()</code>：设置优先级</li><li><code>static yield()</code>：线程让步</li><li><code>join()</code>：线程强行加入（阻塞），一般用<code>try</code></li><li><code>sleep()</code>：延时，单位毫秒</li><li><code>stop()</code>：强制线程结束</li></ul><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>过程：</p><ul><li>新建：实例化一个Thread对象。</li><li>就绪：运行<code>.start()</code>之后，等待CPU时间片。</li><li>运行：线程就绪之后，进行运行状态。</li><li>阻塞：特殊情况时终止自己执行，进入阻塞。</li><li>死亡：完成全部工作或强制终止。</li></ul><h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><ul><li><code>wait()</code>：当前线程挂起并放弃CPU、同步资源，让别的线程可以进行访问并修改。当前线程状态为排队等候，等待被唤醒。</li><li><code>notify()</code>：唤醒排队等候的线程。</li><li><code>notifyAll()</code>：唤醒排队等候的所有线程。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我当初学习java时的一些笔记，这几天翻出来看了一下，感觉可以作为一些参考，由于当时我有C/C++的基础，所以学习的速度非常快，有些地方直接和C/C++进行了对比，所以在观看的时候最好有一些编程基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;语言只是算法的载体，</summary>
      
    
    
    
    <category term="Matrix的笔记本" scheme="https://magic-matrix.gitee.io/categories/Matrix%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="java" scheme="https://magic-matrix.gitee.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>卷积双目匹配</title>
    <link href="https://magic-matrix.gitee.io/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/"/>
    <id>https://magic-matrix.gitee.io/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/</id>
    <published>2021-02-26T11:22:21.000Z</published>
    <updated>2021-10-14T06:58:12.198Z</updated>
    
    <content type="html"><![CDATA[<p>双目立体系统中，匹配算法是必不可少的一个环节，但是当今的双目匹配算法效率并不是非常的理想，我在原有的匹配算法中改进了一种算法，并这种算法甚至可以自成一套体系，我称它为卷积双目匹配。</p><p>接下来我会介绍我的算法原理，我的算法步骤主要分成以下几步：</p><ul><li>图像相对滑动</li><li>图像整体差值</li><li>通过卷积来计算损失矩阵</li><li>从损失矩阵中查找最合适的视差值</li></ul><p>我会使用下面的两幅图片来进行分析：</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/left.jpg" alt="left"></p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/right.jpg" alt="right"></p><h3 id="两张图片的特点"><a href="#两张图片的特点" class="headerlink" title="两张图片的特点"></a>两张图片的特点</h3><p>当左右摆放的相机时，同一个物体在两张图片上的位置会有一个特点：右图片的物体会普遍靠左，左图片物体会靠右。这个现象很容易说明，左相机会照的左面东西多一点，右相机会照右边多一点。</p><p>例如，下图中红色矩形标记的桌角，左图桌角的坐标为（200，190），右图桌角的坐标为（167，190），两张图片的桌角的行坐标为是相同的，都是第190行，但列坐标就不同了，而且左图的列坐标为第200列，右图的列坐标为第167列，很明显左图中桌角和右图中桌角相比较更偏右一点。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/untitled1.jpg" alt="untitled1"></p><p>这个特点会体现在两张图片中所有的物体上，而且，如果这个物体非常靠近相机，这种特点就越明显。在接下来的过程中我会用到这个特点进行处理。</p><h3 id="图像相对滑动"><a href="#图像相对滑动" class="headerlink" title="图像相对滑动"></a>图像相对滑动</h3><p>利用以上两张图片的特点，我们可以得出一个结论：<strong>如果两张图都有一个物体，按照左图这个物体坐标的位置，在右图的这个位置向右寻找，一定能找到左图中相同的物体</strong>。</p><p>这样就可以建立一个新的方法匹配这些相同的地方。如图所示，先将两张图片完整重叠在一起，然后让右图片进行向右滑动，在滑动的过程中，一定会有一些物体会大概重合，就例如图中桌角的情况。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/double.jpg" alt="double"></p><p>每滑动一次就是移动了一个像素，当滑动了$d$个像素，让一个物体部分区域重合的时候，我们可以认为$d$就是当前像素的视差。</p><p>但两张图片不会一直滑动下去，因为没必要，视差值会小于等于整张图片宽度，而等于的情况几乎没有可能，因为一旦等于就意味着物体太靠近相机，导致出现拍摄不全的情况，所以在滑动的时候确定需要滑动多少，太小的话会影响较大的视差部分，太大会加大计算负担，整体时间会增加。我所选的这两张图我预设50次滑动。</p><h3 id="图像整体差值"><a href="#图像整体差值" class="headerlink" title="图像整体差值"></a>图像整体差值</h3><p>大概的方法已经确定下来了，但现在的问题是如何能确定是否某个区域图片已经重合，这里我是使用了减法操作。</p><p>两张图片由于相对滑动，所以可以将重合部分进行相减，而在写程序的时候，可以将左图片的“头部”和右图片的“尾部”去掉就可以保证剩下了重合部分，如图所示。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/error.jpg" alt="error"></p><p>在两张图片重叠的部分进行相减，会得到一个差值矩阵，当两个区域像素值非常接近的时候，进行减法后得到的数值的绝对值会非常的小，因此通过这个矩阵可以观察出，当前滑动$d$像素下哪些区域非常的接近。</p><p>例如，下图是一个模拟出的差值矩阵，若将区域设置成$5*5$，为了进一步比较，将区域A和区域B的数据累加在一起，A区域的累加为24，B区域累加为488，这样说明A区域比较接近，B区域就不太接近，所以A区域更适合当前的视差值$d$（滑动的像素值）。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/2021-01-20_12-26-32.png" alt="2021-01-20_12-26-32"></p><p>所以每次滑动图片，需要计算差值矩阵，差值矩阵计算完后，需要划分区域，每个区域的元素需要累加在一起得到一个值，由于一整张图片会有很多区域，每个区域可以排布成一个新的矩阵，暂时称之为损失矩阵。</p><h4 id="python程序"><a href="#python程序" class="headerlink" title="python程序"></a>python程序</h4><ul><li>裁剪图片函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 裁剪图片函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageCut</span>(<span class="params">image, step</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    image: 需要裁剪的图片</span></span><br><span class="line"><span class="string">    step: 去掉的宽度（有正负之分）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return: 已经裁剪的图片</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> step &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># step是负数，去掉图片“尾部”</span></span><br><span class="line">        image = image[:,:step]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> step &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># step是正数，去掉图片“头部”</span></span><br><span class="line">        image = image[:,step:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># step为0，图片原封不动</span></span><br><span class="line">        image = image</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><ul><li>计算一次差值矩阵</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算一次差值矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageDiff</span>(<span class="params">image_right, image_left, step</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    image_right: 右相机图片原图</span></span><br><span class="line"><span class="string">    image_left: 左相机图片原图</span></span><br><span class="line"><span class="string">    step: 滑动的像素值</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return: 差值矩阵</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 需要改成int16类型，原因如下：</span></span><br><span class="line">    <span class="comment"># 1.无符号类型相减完之后，负数会变成0，所以需要保留负数</span></span><br><span class="line">    <span class="comment"># 2.8位有符号不够用，因为加上了符号位，会丢失最高位的信息</span></span><br><span class="line">    image_left = image_left.astype(np.int16)</span><br><span class="line">    image_right = image_right.astype(np.int16)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左右图片进行“去头”和“去尾”裁剪</span></span><br><span class="line">    image1_cut = imageCut(image_left, step)</span><br><span class="line">    image2_cut = imageCut(image_right, -step)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图片相减再取绝对值，即为差值矩阵</span></span><br><span class="line">    image_cut = np.<span class="built_in">abs</span>(image1_cut - image2_cut)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image_cut</span><br></pre></td></tr></table></figure><h3 id="通过卷积来计算损失矩阵"><a href="#通过卷积来计算损失矩阵" class="headerlink" title="通过卷积来计算损失矩阵"></a>通过卷积来计算损失矩阵</h3><p>卷积运算在信号中非常常用，同时在图像处理中也有很重要作用。卷积运算需要一个 2 维数据和一个卷积核进行运算。</p><p>卷积为如下过程：卷积核旋转180度，但在大多情况下，卷积核是中心对称结构，所以卷积核旋转180度不会影响最后结果。卷积核相当于一个权重的集合，将卷积核在 一个2 维输入数据上进行滑动，根据对准的位置求出所有的加权和，如图所示为其中一种滑动情况。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/3e0200b4dbbc34d2f96e20aa5e072c1ff4a.jpg" alt="20151012211045222"></p><p>下图为卷积运算的全过程。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/1540352487792d4ddd977c6.gif" alt="1540352487792d4ddd977c6"></p><p>不同的卷积核会产生不同的效果，在这里就不过多介绍卷积核的类型，接下来用到的卷积核是全1矩阵。</p><p>这种全是1的矩阵可以将每个区域的所有元素进行累加，这正符合目前的需求，每一次滑动可以说是一次计算当前区域的损失值，只需要一个卷积计算就可以直接出所有区域的损失值，。</p><p>这里巧妙利用了卷积的特点，灵感来自于一款卷积神经网络的论文，详细内容直接看我所提供的链接:</p><p><a href="https://www.researchgate.net/publication/259441043_OverFeat_Integrated_Recognition_Localization_and_Detection_using_Convolutional_Networks">OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks</a></p><p>当然也可以看下面这张图，那篇文章中对我比较重要的部分。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/2020-11-20_19-44-40.png" alt="2020-11-20_19-44-40"></p><p>由于每次图片相对滑动都可以获得一个差值矩阵，所以经过卷积后，同样还可以获得一个损失矩阵，由于我预设了50次滑动，所以会得到50个损失矩阵。</p><h4 id="python程序-1"><a href="#python程序-1" class="headerlink" title="python程序"></a>python程序</h4><ul><li>计算损失矩阵</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeImageCost</span>(<span class="params">image_right, image_left, step, core_size</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    image_right: 右相机图片原图</span></span><br><span class="line"><span class="string">    image_left: 左相机图片原图</span></span><br><span class="line"><span class="string">    step: 滑动的像素值</span></span><br><span class="line"><span class="string">    core_size: 卷积核尺寸</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return: 损失矩阵（不完整）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用计算差值矩阵函数，得到差值矩阵</span></span><br><span class="line">    diff = imageDiff(image_right,image_left, step)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 制作卷积核，尺寸为 core_size * core_size 大小的全1矩阵</span></span><br><span class="line">    core = makeCore(core_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过卷积计算损失矩阵</span></span><br><span class="line">    cost = myConv(diff, core)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><h3 id="从损失矩阵中查找最合适的视差值"><a href="#从损失矩阵中查找最合适的视差值" class="headerlink" title="从损失矩阵中查找最合适的视差值"></a>从损失矩阵中查找最合适的视差值</h3><p>目前为止，根据图片滑动50次，已经计算出了50个损失矩阵，但由于相对滑动，重叠的部分越来越小，50个矩阵的宽度并不相同，只有矩阵的行数相同。为了保持所有的损失矩阵宽度相同，需要把矩阵缺失的部分手动补上。由此可见补上的部分会越来越大，补上的部分每次都会增加一个像素宽度，直到滑动结束。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/coss.jpg" alt="coss"></p><p>损失矩阵有个特点，由于卷积前所有值取绝对值，即使经过卷积，所有的值都是正数，为了方便区分补上的部分，补上的值可以使用-1，这样可以保证正数部分是有效的损失。</p><p>有了50个相同大小的矩阵后，将它们排列起来，没有滑动的损失矩阵放在最前面，接着后面是滑动1个像素的损失矩阵，以此类推，滑动第49个像素的损失矩阵放在最后，这就形成了一个立方体的三维矩阵。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/square.jpg" alt="square"></p><p>现在就可以检查同50个损失矩阵中的相同位置的大小，其本质是比较一个三维矩阵的第三个维度上的的最小值，在最小值所处的滑动次数，就是该像素的<strong>视差值</strong>。</p><p>例如，如图所示，比较50个损失矩阵最左上角的大小，假设第3个损失矩阵（滑动3像素）的左上角值最小，左上角的视差值为3。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/which.jpg" alt="which"></p><p>由于之前做过添加-1的处理，所以写程序的时候结合-1的特殊，可以跳过-1的部分，直接找出非负数中最小的值。</p><p>通过查找所有损失矩阵最小的损失之后会形成一张新的图，该图为最终视差图。</p><p><img src="/2021/02/%E5%8D%B7%E7%A7%AF%E5%8F%8C%E7%9B%AE%E5%8C%B9%E9%85%8D/img.png" alt="img"></p><h4 id="python程序-2"><a href="#python程序-2" class="headerlink" title="python程序"></a>python程序</h4><ul><li>补上损失矩阵缺失部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补上损失矩阵缺失部分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeCostMatrix</span>(<span class="params">image_cost,step, temp</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    image_cost: 损失矩阵（不完整）</span></span><br><span class="line"><span class="string">    step: 滑动像素值</span></span><br><span class="line"><span class="string">    temp: 补上的数值</span></span><br><span class="line"><span class="string">    return: 损失矩阵（完整）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测量出损失矩阵的行数</span></span><br><span class="line">    image_h = image_cost.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先制作一个全1矩阵</span></span><br><span class="line">    <span class="comment"># 全1矩阵乘上一个数，这个矩阵会变成全是这个数</span></span><br><span class="line">    tem_matrix = np.ones((image_h,step), dtype=np.int16) * temp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    image_step = np.hstack((image_cost , tem_matrix))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image_step</span><br></pre></td></tr></table></figure><ul><li>计算视差图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算视差图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computParallax</span>(<span class="params">right_img,left_img,N = <span class="number">30</span>, core_size = <span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    right_img: 右相机图片原图</span></span><br><span class="line"><span class="string">    left_img: 左相机图片原图</span></span><br><span class="line"><span class="string">    N: 迭代次数（相对滑动次数）</span></span><br><span class="line"><span class="string">    core_size: 卷积核的尺寸，默认是5，建议调大一点</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return: 视差图</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N): </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算出不完整的损失矩阵</span></span><br><span class="line">        img_cost = makeImageCost(right_img,left_img,i,core_size)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 补上缺失的部分，损失矩阵变得完整</span></span><br><span class="line">        <span class="comment"># 我并没有补上-1，我补上的是一个很大的值，比图片宽度还大</span></span><br><span class="line">        <span class="comment"># 这样在比较大小的时候，省去了排除补上数值的工作</span></span><br><span class="line">        <span class="comment"># 可以直接比较大小，找到最小值</span></span><br><span class="line">        number = right_img.shape[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        image_step = makeCostMatrix(img_cost,i,number)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 0的情况下，损失矩阵立方体只是一个二维矩阵</span></span><br><span class="line">            num_matix = image_step</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不断往后面放二维矩阵，最终形成损失矩阵立方体</span></span><br><span class="line">            num_matix = np.dstack((num_matix,image_step))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 在损失矩阵立方体的第三个维度上找到最小值</span></span><br><span class="line">    <span class="comment"># 这个值的索引为视差</span></span><br><span class="line">    min_cost = np.argmin(num_matix, axis=<span class="number">2</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_cost</span><br></pre></td></tr></table></figure><ul><li>剩下的程序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用opencv显示图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageShow</span>(<span class="params">image,second = <span class="number">0</span></span>):</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;image&quot;</span>,image)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(second) &amp; <span class="number">0xFF</span> == <span class="number">0x20</span>:</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 图片路径</span></span><br><span class="line">    Path_left  = <span class="string">&quot;img\\left.jpg&quot;</span></span><br><span class="line">    Path_right = <span class="string">&quot;img\\right.jpg&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图片</span></span><br><span class="line">    left_img  = cv2.imread(Path_left,<span class="number">0</span>)</span><br><span class="line">    right_img = cv2.imread(Path_right,<span class="number">0</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 计算视差图</span></span><br><span class="line">    min_cost = computParallax(right_img,left_img,N = <span class="number">30</span>, core_size = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示视差图，视差值太小了，乘个5清楚一些</span></span><br><span class="line">    imageShow(min_cost * <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存图片</span></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;img.png&#x27;</span>,min_cost)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;双目立体系统中，匹配算法是必不可少的一个环节，但是当今的双目匹配算法效率并不是非常的理想，我在原有的匹配算法中改进了一种算法，并这种算法甚至可以自成一套体系，我称它为卷积双目匹配。&lt;/p&gt;
&lt;p&gt;接下来我会介绍我的算法原理，我的算法步骤主要分成以下几步：&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="机器视觉" scheme="https://magic-matrix.gitee.io/categories/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="双目立体成像" scheme="https://magic-matrix.gitee.io/tags/%E5%8F%8C%E7%9B%AE%E7%AB%8B%E4%BD%93%E6%88%90%E5%83%8F/"/>
    
    <category term="python" scheme="https://magic-matrix.gitee.io/tags/python/"/>
    
    <category term="图像处理" scheme="https://magic-matrix.gitee.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>这就是我的信条</title>
    <link href="https://magic-matrix.gitee.io/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/"/>
    <id>https://magic-matrix.gitee.io/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/</id>
    <published>2021-02-21T12:36:02.000Z</published>
    <updated>2021-10-14T06:59:03.869Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间我看了《信条》，我很喜欢这部电影，而且这部电影让我百感交集，并不是电影中复杂的设定，而是它触及到了我最沮丧的时刻，让我明确了属于我的自己的人生观。</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/p2618994146.webp" alt="p2618994146"></p><p>整部电影描述了一个重要的概念：<strong>熵</strong>。</p><p>什么是熵，熵是热力学中重要概念，用来描述一个体系混乱程度的度量，有序则对应熵低，混乱对应熵高。下图是一个例子，刚开始的时候非常有序（因为我们提前摆好了字母），然后让它随机运动，最后非常的混乱，这就是一个<strong>熵增</strong>的过程。</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/asfahd.webp" alt="v2a5a0"></p><p>熵很重要，是因为它总结了宇宙的基本发展规律：宇宙中的事物都有自发变得更混乱的倾向，也就是说熵会一直增加。破镜难以重圆，青春不会永驻，一切事物正在朝着一个<strong>方向</strong>去演变。蜡烛燃烧、冰块融化、酒精挥发、食物腐烂等都是熵增加的过程。</p><p>很不可思议吧，我们的世界熵在不断增加，电影有意思的地方就是，构造了一个熵减的世界，整体下来与真实世界相反。一个熵增，一个熵减，整部电影玩出各种想不到的操作，诺兰真的很厉害。</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/cefc1e178a82b901c2a.jpeg" alt="cefc1e178a82b901c2a"></p><p>但这篇文章关注点不是熵，我只是想用熵来引出另一个细思极恐的概念。</p><p>弹一枚硬币，如果能知道所用的力量、空气阻力等等所有因素，把这些因素量化成数据，根据这些数据是能百分百计算出接下来硬币落地的朝向。</p><p>这件事我们人类达不到，如果有一位“<strong>圣人</strong>”，他通晓万物，那么他能用此时这一秒的状态，预测出下一秒的状态。进而言之，一直这样预测，未来就不会有任何隐瞒，当然也可以根据此时状态推演过去。这样看来这位“圣人”能所知这一切，包括未来和过去。</p><p>简单总结一下，这个世界是服从因果律，也就是说，每一件事情的发生，都是有它的原因，我们能通过一件事的“因”去推出“果”，反之也可以从“果”反推出“因”。这就是著名的“<strong>拉普拉斯之妖</strong>”。</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/09fb1.jpeg" alt="09fb1"></p><p>原话放在这里：</p><blockquote><p><strong><em>“We may regard the present state of the universe as the effect of its past and the cause of its future. An intellect which at a certain moment would know all forces that set nature in motion, and all positions of all items of which nature is composed, if this intellect were also vast enough to submit these data to analysis, it would embrace in a single formula the movements of the greatest bodies of the universe and those of the tiniest atom; for such an intellect nothing would be uncertain and the future just like the past would be present before its eyes.”</em></strong></p></blockquote><p>听起来很正常，确实是我们生活中的一些经验，但仔细想想，我们这个“因”是只能推出一个“果”，这就很恐怖了。那是不是说明，从过去到现在再到未来，由于这一段存在的因果，导致整个过程是<strong>注定的</strong>，一切都被宇宙安排好了。</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/d59d08caf3f929ceaa195f32b_720w.jpg" alt="d59d08caf3f929ceaa195f32b_720w"></p><p>从另一个角度来谈一下，我们人体的微观是原子构成，其中我们人体进行的生理活动和新陈代谢都是原子的各种化学反应。那我们所做的事，都是“一团”原子在驱使，就像信条男主发出的疑问：那自由意志呢？</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/93747716139134832.png" alt="9374776139134832"></p><p>很难想象，我所做的一切，不是我想出来的，都是被宇宙安排好，我们不过是在一步一步执行它，甚至我打下的这篇文章，也是在它的安排中。正如影片最后，尼尔明知道最后的结局，但他还是走进了那扇门，他也在鼓励着自己：<strong>这是对这个世界运作的信念，而不是袖手旁观的借口</strong>。</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/850019116139166642.png" alt="850019116139166642"></p><p>爱因斯坦写给泰戈尔的一封信中这样写道：</p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/73822816139174882.png" alt="73822816139174882"></p><blockquote><p>如果月亮在其环绕地球的永恒运动中被赋予自我意识，它就会完全确信，它是按照自己的决定在其轨道上一直运动下去，这样会有一个具有更高洞察力和更完备智力的存在物，注视着人和人的所作所为，嘲笑人以为他按照自己的自由意识而行动的错觉。</p></blockquote><p>爱因斯坦的下一句话是：</p><p><strong><em>这就是我的信条</em></strong></p><p><img src="/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E4%BF%A1%E6%9D%A1/yjjahn.jpg" alt="yjjahn"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前段时间我看了《信条》，我很喜欢这部电影，而且这部电影让我百感交集，并不是电影中复杂的设定，而是它触及到了我最沮丧的时刻，让我明确了属于我的自己的人生观。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/02/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88</summary>
      
    
    
    
    <category term="坐在夕阳下的思考" scheme="https://magic-matrix.gitee.io/categories/%E5%9D%90%E5%9C%A8%E5%A4%95%E9%98%B3%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83/"/>
    
    
    <category term="我的超现实主义人生" scheme="https://magic-matrix.gitee.io/tags/%E6%88%91%E7%9A%84%E8%B6%85%E7%8E%B0%E5%AE%9E%E4%B8%BB%E4%B9%89%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>开开心心玩树莓派</title>
    <link href="https://magic-matrix.gitee.io/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <id>https://magic-matrix.gitee.io/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/</id>
    <published>2021-02-18T05:42:07.000Z</published>
    <updated>2021-10-14T06:58:19.007Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇长系列，就是折腾折腾，玩玩树莓派。</p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/1317609387fm.jpeg" alt="1317609387fm" style="zoom:50%;"></p><p>我使用的是树莓派3b，其他版本的基本操作都差不多。</p><h2 id="树莓派装系统"><a href="#树莓派装系统" class="headerlink" title="树莓派装系统"></a>树莓派装系统</h2><p>树莓派不装系统，和板砖没什么区别，当然还没板砖有分量，所以至少装个系统吧。</p><p>首先，简单科普一下，树莓派的CPU是<strong>ARM</strong>架构（嵌入式工程师狂喜），所以我们可以下载个linux系统玩玩，就装官方的系统即可，毕竟官方系统稳定，否则你一定不喜欢改一些奇奇怪怪的bug。</p><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><ol><li>树莓派就是一台小电脑，需要一张<strong>tf卡</strong>，这是用来装系统的，最小为4GB，最好使用Class 10，写入速度可以达到10MB/s，这样使用起来就比较流畅。有卡了就需要<strong>读卡器</strong>，不要使用笔记本自带的SD卡插槽，不管用，烧不进去系统，来自我自己带泪的提醒。tf卡最好格式化一下（备份重要资料，格式化就没了），最好是fat32格式。</li><li>网线</li><li>电源线</li></ol><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>现在有卡了，就需要系统镜像，可以去官网去找：</p><blockquote><p><a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a></p></blockquote><p>官网推荐了三种系统，如图所示：</p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_14-12-50.png" alt="2021-02-18_14-12-50"></p><p>简单介绍一下：</p><ul><li>第一个是带<strong>图形界面</strong>和<strong>常用软件</strong>，比较推荐下载。</li><li>第二个只有<strong>图形界面</strong>。</li><li>第三个是精简版，其实只有个linux核心还有其他映射。</li></ul><p>我就直接下载了第一个了，而且这三套系统<strong>所有版本</strong>树莓派都适用。</p><p>唉，第一个镜像是2G大小，而且还是国外服务器，等了好久。</p><p>下载完就解压出来，是个<code>.img</code>文件。</p><h3 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h3><p>首先需要个win32软件，这个软件我已经放在了我的云盘里，点击后面链接就可以下载了（<a href="https://wws.lanzous.com/in7tclstrej">点击下载</a>，密码：h21i）。</p><p>接下来就把插上tf卡的读卡器插到电脑上，打开已经下载好的win32软件，下图为简单操作，需要填入镜像路径和插上的读卡器盘符，然后就可以点击<code>write</code>就可以写入了。</p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_14-52-25.png" alt="2021-02-18_14-52-25"></p><p>写入时间有点久，等一下吧。</p><h3 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h3><p>我没有备用的显示屏，但linux可以使用ssh进行访问，所以接下来的操作全部是使用win10上使用ssh敲命令。</p><p>但在此之前，需要开启ssh，老版本的镜像中，ssh是默认打开，新版本就不一样了，需要先手动打开。</p><p>打开方法很简单，首先读卡器不要拔下来，先打开tf卡，新建一个文本文件，改成<code>SSH</code>，<strong>注意没有后缀</strong>。</p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_15-19-20.png" alt="2021-02-18_15-19-20"></p><p>这样就行了，读卡器拔下来，tf卡插在树莓派上。</p><p>树莓派是有个以太网接口的，所以用网线连接，接在路由器的LAN口上，我的电脑也连接了路由器，所以我的电脑和树莓派就在同一个局域网之下，然后给树莓派供电就可以直接启动。</p><p>还需要知道树莓派目前的ip地址，因为在路由器局域网之下，我可以直接去路由器后台去看看树莓派的ip地址。</p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_15-30-27.png" alt="2021-02-18_15-30-27"></p><p>现在知道了ip地址：<code>192.163.0.109</code>，不要去记这个地址，路由器使用的是DHCP自动分配ip地址，所以每次开机可能都不一样，如果嫌麻烦，可以一会去设置固定ip，方便每次连接。</p><p>现在可以连接ssh了，我用的是putty，而且我找到了个汉化版（<a href="https://wws.lanzous.com/ip6rolstrfa">点击下载</a>，密码：he44）。</p><p>所以根据下图去配置，当然机灵点，ip地址别填我的。端口号是22，这是ssh默认端口号。</p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_15-37-21.png" alt="2021-02-18_15-37-21"></p><p>打开之后会出现登录用户，默认用户是<code>pi</code>，密码是：<code>raspberry</code></p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_15-48-43.png" alt="2021-02-18_15-48-43"></p><p>需要注意的是，密码输入是不显示的，需要仔细输入。</p><p>现在就可以使用树莓派其他操作了。</p><h2 id="VNC远程操作"><a href="#VNC远程操作" class="headerlink" title="VNC远程操作"></a>VNC远程操作</h2><p>如果用不惯命令行可以使用VNC软件进行远程操作。</p><p>你的电脑是需要这个软件的，我也在这里给出了下载链接（<a href="https://wws.lanzous.com/iYHtalstrgb">点击下载</a>，密码：7ad6）。</p><p>同时你的树莓派也需要安装这个软件，直接打下面的命令即可安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tightvncserver</span><br></pre></td></tr></table></figure><p>稍微等一会就下载完成，之后想打开这个软件直接输入下面命令就可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tightvncserver</span><br></pre></td></tr></table></figure><p>第一次需要设置一个进入VNC密码，我建议就是<code>raspberry</code>，毕竟混不了。</p><p>树莓派打开VNC后，使用电脑远程登录，打开下载好的软件，输入ip地址，后面加上端口号1。点击Connect后会输入密码，就是刚才设置的密码。</p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_16-07-28.png" alt="2021-02-18_16-07-28"></p><p><img src="/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/2021-02-18_16-13-11.png" alt="2021-02-18_16-13-11"></p><h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p>建议使用命令关机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo poweroff</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一篇长系列，就是折腾折腾，玩玩树莓派。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/02/%E5%BC%80%E5%BC%80%E5%BF%83%E5%BF%83%E7%8E%A9%E6%A0%91%E8%8E%93%E6%B4%BE/1317609387fm.jpe</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://magic-matrix.gitee.io/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="linux" scheme="https://magic-matrix.gitee.io/tags/linux/"/>
    
    <category term="安装" scheme="https://magic-matrix.gitee.io/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
</feed>
