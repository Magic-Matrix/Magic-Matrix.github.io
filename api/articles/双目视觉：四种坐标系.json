{"title":"双目视觉：四种坐标系","slug":"双目视觉：四种坐标系","date":"2021-01-17T11:36:18.000Z","updated":"2021-02-03T11:45:27.836Z","comments":true,"path":"api/articles/双目视觉：四种坐标系.json","excerpt":"本篇文章主要针对于机器视觉常用的坐标系的介绍以及推演，坐标系一共有四种：世界坐标系、相机坐标系、像素坐标系、图像坐标系。除了一些计算过程，还有一部分代码示例。","covers":["/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/axis.png","/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/cri.png","/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/cam2pic.png","/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/pic2uv.png","/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/all.png"],"content":"<p>本篇文章主要针对于机器视觉常用的坐标系的介绍以及推演，坐标系一共有四种：世界坐标系、相机坐标系、像素坐标系、图像坐标系。除了一些计算过程，还有一部分代码示例。</p>\n<a id=\"more\"></a>\n<h2 id=\"坐标系简介\"><a href=\"#坐标系简介\" class=\"headerlink\" title=\"坐标系简介\"></a>坐标系简介</h2><p>注：本篇文章中四种坐标系都是<strong>左手坐标系</strong>，有些时候比如matlab所使用的就是右手坐标系，这个不会有太大的影响</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/axis.png\" alt=\"axis\"></p>\n<h3 id=\"世界坐标系\"><a href=\"#世界坐标系\" class=\"headerlink\" title=\"世界坐标系\"></a>世界坐标系</h3><ul>\n<li>庞大世界中的坐标系，可以表示万物的位置</li>\n<li>单位：m</li>\n<li>一般表述相机位置和实物位置</li>\n<li>Ow-XwYwZw来表示</li>\n<li>Ow是原点，双目系统中可以将任意一个摄像头的光心设置成原点，即世界坐标系和相机坐标系重合</li>\n</ul>\n<h3 id=\"相机坐标系\"><a href=\"#相机坐标系\" class=\"headerlink\" title=\"相机坐标系\"></a>相机坐标系</h3><ul>\n<li>存在于相机成像原理上，方便光的直线传播</li>\n<li>单位：m</li>\n<li>Oc-XcYcZc来表示</li>\n<li>Oc是原点，相机光心的位置，所有光都汇聚这一点</li>\n</ul>\n<h3 id=\"像素坐标系\"><a href=\"#像素坐标系\" class=\"headerlink\" title=\"像素坐标系\"></a>像素坐标系</h3><ul>\n<li>一张图片中的每个像素位置</li>\n<li>UV表示，但实际上有第三个坐标轴，用来表示颜色程度</li>\n<li>原点在左上角</li>\n</ul>\n<h3 id=\"图像坐标系\"><a href=\"#图像坐标系\" class=\"headerlink\" title=\"图像坐标系\"></a>图像坐标系</h3><ul>\n<li>O-XY来表示</li>\n<li>原点位于光轴上的一个点，用物理单位表示像素的位置</li>\n</ul>\n<h2 id=\"变换\"><a href=\"#变换\" class=\"headerlink\" title=\"变换\"></a>变换</h2><h3 id=\"世界坐标到相机坐标系\"><a href=\"#世界坐标到相机坐标系\" class=\"headerlink\" title=\"世界坐标到相机坐标系\"></a>世界坐标到相机坐标系</h3><h4 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h4><p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/cri.png\" alt=\"cri\"></p>\n<p>z轴是被围绕旋转的轴，z上的坐标保持不变。</p>\n<p>图片为o-x’y’z’旋转成o-xyz的过程</p>\n<script type=\"math/tex; mode=display\">\nx = x' cos(\\theta) - y' sin(\\theta) \\\\\ny = x' sin(\\theta) + y' cos(\\theta) \\\\\nz = z'</script><p>写成矩阵形式：</p>\n<script type=\"math/tex; mode=display\">\n绕Z轴旋转：\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   cos(\\theta) & -sin(\\theta) & 0\\\\\n   sin(\\theta) & cos(\\theta) & 0 \\\\\n   0 & 0 & 1 \n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} = R_1 \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix}</script><script type=\"math/tex; mode=display\">\n绕X轴旋转：\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   1 & 0 & 0\\\\\n   0 & cos(\\psi) & sin(\\psi)\\\\\n   0 & -sin(\\psi) & cos(\\psi) \n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} = R_2 \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix}</script><script type=\"math/tex; mode=display\">\n绕Y轴旋转：\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   cos(\\omega) & 0 & -sin(\\omega)\\\\\n   0 & 1 & 0 \\\\\n   sin(\\omega) & 0 & cos(\\omega) \n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} = R_3 \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix}</script><p>于是旋转矩阵可以表示为三个矩阵相乘：</p>\n<script type=\"math/tex; mode=display\">\nR = R_1 R_2 R_3</script><ul>\n<li>这里我们讨论一下旋转矩阵的一些性质：<ul>\n<li>三个旋转矩阵都是<strong>满秩</strong>（代数余子式可以算出旋转矩阵的行列式永远为1，也就是永远不会等于零）。</li>\n<li>没有旋转的时候就变成了单位矩阵。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h4><p>平移只需要在一个坐标基础上直接加上偏移量就可以实现平移：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} + \n\n  \\begin{bmatrix}\n   x_t \\\\\n   y_t \\\\\n   z_t\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} + T</script><h4 id=\"综合到坐标系转换\"><a href=\"#综合到坐标系转换\" class=\"headerlink\" title=\"综合到坐标系转换\"></a>综合到坐标系转换</h4><p>由此可以推广到世界坐标系乘上一个旋转矩阵，转换成和相机坐标系相同方向的新坐标系，但需要一个平移T将坐标系平移过去：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   X_c \\\\\n   Y_c \\\\\n   Z_c\n  \\end{bmatrix} = R\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w\n  \\end{bmatrix} + T</script><p>但上面的公式比较麻烦，写成下面的方式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   X_c \\\\\n   Y_c \\\\\n   Z_c \\\\\n   1\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   R & T \\\\\n   \\vec{0} & 1 \\\\\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><ul>\n<li>R为旋转矩阵，（3*3）</li>\n<li>T为偏移向量，（3*1）</li>\n<li>零向量为（1*3）</li>\n</ul>\n<p>其实，我不喜欢这种形式，这种形式为了追求规整，放弃了一些比较好的特性，这个主要看个人习惯。我在接下来使用的时候为了计算方便，会再次拆开。</p>\n<h3 id=\"相机坐标系到图像坐标系\"><a href=\"#相机坐标系到图像坐标系\" class=\"headerlink\" title=\"相机坐标系到图像坐标系\"></a>相机坐标系到图像坐标系</h3><p>两种坐标系存在透视关系，是一种从3D转换到2D的转换，其中可以使用相似三角形进行比例计算。</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/cam2pic.png\" alt=\"cam2pic\"></p>\n<p>图中有两个相似三角形：</p>\n<script type=\"math/tex; mode=display\">\n\\triangle ABO_C \\sim \\triangle OCO_c \\\\\n\\triangle PBO_C \\sim \\triangle pCO_c</script><p>从两个相似三角形中可以找到一些长度的关系：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{AB}{oC} = \\frac{AO_c}{oO_c} = \\frac{BO_c}{CO_c} = \\frac{PB}{pC}</script><p>其中有些可以用其他表示：</p>\n<script type=\"math/tex; mode=display\">\nAB = X_c, oC = x\\\\\nAO_c = Z_c, oO_c = f \\\\\nPB = Y_c, pC = y</script><p>于是重新更改一下就变成了新的式子：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{X_c}{x} = \\frac{Y_c}{y} = \\frac{Z_c}{f}</script><p>我们的目的是想表示出图像坐标系，也就是用其他变量去表示(x,y)，这个时候就可以进行简单修改：</p>\n<script type=\"math/tex; mode=display\">\nx = f \\frac{X_c}{Z_c} \\\\\ny = f \\frac{Y_c}{Z_c}</script><p>接下来就转换成矩阵形式</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   x \\\\\n   y \\\\\n   1\n  \\end{bmatrix} = \n  \\begin{bmatrix}\n   f & 0 & 0 & 0 \\\\\n   0 & f & 0 & 0\\\\\n   0 & 0 & 1 & 0\n  \\end{bmatrix}\n  \\begin{bmatrix}\n   x_c \\\\\n   y_c \\\\\n   z_c \\\\\n   1\n  \\end{bmatrix}</script><h3 id=\"图像坐标系到像素坐标系\"><a href=\"#图像坐标系到像素坐标系\" class=\"headerlink\" title=\"图像坐标系到像素坐标系\"></a>图像坐标系到像素坐标系</h3><p>两个坐标系之间不存在旋转变换，只是原点坐标会有所差距而已</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/pic2uv.png\" alt=\"pic2uv\"></p>\n<p>这里假设每一个像素在u轴和v轴方向上的物理尺寸为dx和dy，可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nu = \\frac{x}{dx} + u_0 \\\\\nv = \\frac{y}{dy} + v_0 \\\\</script><p>写成矩阵形式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   \\frac{1}{dx} & 0 & u_0\\\\\n   0 & \\frac{1}{dy} & v_0\\\\\n   0 & 0 & 1\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x \\\\\n   y \\\\\n   1\n  \\end{bmatrix}</script><h2 id=\"综合四种坐标系的相互变换\"><a href=\"#综合四种坐标系的相互变换\" class=\"headerlink\" title=\"综合四种坐标系的相互变换\"></a>综合四种坐标系的相互变换</h2><h3 id=\"整合\"><a href=\"#整合\" class=\"headerlink\" title=\"整合\"></a>整合</h3><p>之前讨论了每两个坐标系之间都有一套变换的方法，接下来就可以把这些方法全部综合在一起，生成一个比较复杂的公式，这个公式所表达的意思就是<strong>世界坐标</strong>和<strong>像素坐标</strong>的相互转化。</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/all.png\" alt=\"all\"></p>\n<p>用矩阵公式表达：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n  \\begin{bmatrix}\n   \\frac{1}{dx} & 0 & u_0\\\\\n   0 & \\frac{1}{dy} & v_0\\\\\n   0 & 0 & 1\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   f & 0 & 0 & 0 \\\\\n   0 & f & 0 & 0\\\\\n   0 & 0 & 1 & 0\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   R & T \\\\\n   \\vec{0} & 1 \\\\\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><p>接下来我们重新定义一组数据：</p>\n<script type=\"math/tex; mode=display\">\nf_x = \\frac{f}{dx} \\\\\nf_y = \\frac{f}{dy} \\\\</script><p>以上定义的两数据并没有太大的物理意义，仅仅是因为书写简单方便观看。既然有这种定义式了，那么矩阵中有些地方可以进行相乘，进一步简化：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       f_x & 0 & u_0 & 0 \\\\\n       0 & f_y & v_0 & 0\\\\\n       0 & 0 & 1 & 0\n      \\end{bmatrix}\n  } \\\\ 相机内参\n  \\end{matrix}\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       R & T \\\\\n       \\vec{0} & 1 \\\\\n      \\end{bmatrix}\n  } \\\\ 相机外参\n  \\end{matrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}\n\n \\tag{1}</script><p>公式中我分成了两部分，一个矩阵作为相机外参，另一个矩阵作为相机内参：</p>\n<ul>\n<li><p>相机内参：</p>\n<p>这个涉及到相机的构造，有些摄像头买来后，直接去测焦距像素大小可能会很麻烦，而且还不准确，所以这个矩阵一般不会用公式推导求出，这里建议采用张正友标定获取，在matlab中提供了这个程序，只要拍摄几张图片就可以直接获取相机内参。</p>\n<p><strong>注意</strong>：matlab中的世界坐标轴有点不太一样，使用的是世界右手坐标系，所以把y轴方向变成了反向</p>\n</li>\n<li><p>相机外参：</p>\n<p>这个矩阵是描述相机位置，例如在双目系统中，将一个摄像头光心设置成世界坐标系原点时，另一个摄像头可以根据原点进行一个变换，形成了一个新的坐标。</p>\n</li>\n</ul>\n<p>但我并不喜欢以上公式，整个公式是一步一步推理出来的，有几个地方反而有些冗余，我按照我自己的想法稍微修改了一点：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       f_x & 0 & u_0 \\\\\n       0 & f_y & v_0\\\\\n       0 & 0 & 1\n      \\end{bmatrix}\n  } \\\\ 相机内参\n  \\end{matrix}\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       R & T \\\\\n\n      \\end{bmatrix}\n  } \\\\ 相机外参\n  \\end{matrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}\n\n  \\tag{2}</script><p>我去点了相机内参中的最后一列和相机外参中最后一行，因为在整体计算中并没有什么作用，以上两个公式都可以使用，主要是怎么方便就用哪个公式去写代码。</p>\n<p>如果还想再简化一下，就可以写成这样：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n C\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}\n\n\\tag{3}</script><p>这里的C是一个3*4的矩阵，简化成这样，里面具体的元素已经没有太大的物理含义了，但这样书写有个好处，提前计算出C之后就可以直接使用C来计算整个算式。</p>\n<p>通过以上公式，很容易做到三维空间中的一个点在图像中的像素坐标，但反过来就，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。</p>\n<h3 id=\"像素和世界的相互转换\"><a href=\"#像素和世界的相互转换\" class=\"headerlink\" title=\"像素和世界的相互转换\"></a>像素和世界的相互转换</h3><ul>\n<li><strong><em>注</em></strong>：接下来的操作一定要知道深度（Zc或Zw）才能进行，虽然我们目的是求深度，但不影响我们使用下面的几个公式：</li>\n</ul>\n<h4 id=\"像素坐标转换成世界坐标\"><a href=\"#像素坐标转换成世界坐标\" class=\"headerlink\" title=\"像素坐标转换成世界坐标\"></a>像素坐标转换成世界坐标</h4><p>我把<strong>公式(3)</strong>改一下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n  \\frac{1}{Z_c}\n    C\n   \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><p>仅仅是把Zc移到了右边，其实如果世界坐标和相机坐标系重合的话，Zc=Zw。</p>\n<p>整个函数的意思是，如果我们知道了世界坐标中具体的某一点坐标三个数值，就可以直接带入，求出u,v。</p>\n<h4 id=\"世界坐标转换成像素坐标\"><a href=\"#世界坐标转换成像素坐标\" class=\"headerlink\" title=\"世界坐标转换成像素坐标\"></a>世界坐标转换成像素坐标</h4><p>这时候我们不能去用<strong>公式(3)</strong>去修改，我们可以换个思路，使用<strong>公式(2)</strong>去修改：</p>\n<p>由于<strong>公式(2)</strong>中的相机内参是一个3*3的<strong>对角矩阵</strong>，而且很明显是一个可逆矩阵（对角中不会出现0），那么就可以求出这个矩阵的逆矩阵，写成以下形式：</p>\n<script type=\"math/tex; mode=display\">\nZ_c\n  \\begin{bmatrix}\n  f_x & 0 & u_0 \\\\\n  0 & f_y & v_0\\\\\n  0 & 0 & 1\n  \\end{bmatrix}^{-1}\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} \n\n\n    =\n \\begin{bmatrix}\n R & T \\\\\n\n\\end{bmatrix}\n\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><p>简单计算一下，等号左边最后计算的结果是一个3*1的矩阵，右边部分我们换个思路，回想一下外参矩阵的推演过程，我们可以写成这样：</p>\n<script type=\"math/tex; mode=display\">\nZ_c\n  \\begin{bmatrix}\n  f_x & 0 & u_0 \\\\\n  0 & f_y & v_0\\\\\n  0 & 0 & 1\n  \\end{bmatrix}^{-1}\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} \n   =\n R \n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \n\n  \\end{bmatrix}\n   + T</script><p>那么所有矩阵往左边移动：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \n  \\end{bmatrix}\n  =R^{-1}\n\\Bigg(\nZ_c\n  \\begin{bmatrix}\n  f_x & 0 & u_0 \\\\\n  0 & f_y & v_0\\\\\n  0 & 0 & 1\n  \\end{bmatrix}^{-1}\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix}   - T \\Bigg)</script><p>虽然在双目系统中，我们做不到提前给出Zc或Zw，所以以上公式进行参考即可，在一定程度上还是比较方便。</p>\n<h2 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> scipy.io <span class=\"keyword\">as</span> sio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CameraMatrix</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, path = <span class=\"string\">&#x27;camera_data.mat&#x27;</span></span>):</span></span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"comment\"># 从camera_data.mat文件中导入数据</span></span><br><span class=\"line\">\t\tdata=sio.loadmat(path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.leftInsideMatrix = data[<span class=\"string\">&#x27;leftInsideMatrix&#x27;</span>]</span><br><span class=\"line\">\t\tself.rightInsideMatrix = data[<span class=\"string\">&#x27;rightInsideMatrix&#x27;</span>]</span><br><span class=\"line\">\t\tself.leftOutsideMatrix = data[<span class=\"string\">&#x27;leftOutsideMatrix&#x27;</span>]</span><br><span class=\"line\">\t\tself.rightOutsideMatrix = data[<span class=\"string\">&#x27;rightOutsideMatrix&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.__dataInit()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__dataInit</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 分解出旋转矩阵</span></span><br><span class=\"line\">\t\tself.left_R  = self.leftOutsideMatrix[:<span class=\"number\">3</span>,:<span class=\"number\">3</span>]</span><br><span class=\"line\">\t\tself.right_R = self.rightOutsideMatrix[:<span class=\"number\">3</span>,:<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 分解出偏移向量</span></span><br><span class=\"line\">\t\tself.left_T  = self.leftOutsideMatrix[:<span class=\"number\">3</span>,-<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\tself.right_T = self.rightOutsideMatrix[:<span class=\"number\">3</span>,-<span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\to = np.array([<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]).reshape(-<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 制作出规整的相机内参</span></span><br><span class=\"line\">\t\tleftInsideMatrix  = np.concatenate((self.leftInsideMatrix,o),axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\trightInsideMatrix = np.concatenate((self.rightInsideMatrix,o),axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 计算出完整相机参数</span></span><br><span class=\"line\">\t\tself.leftCameraMatrix = np.dot(leftInsideMatrix, self.leftOutsideMatrix)</span><br><span class=\"line\">\t\tself.rightCameraMatrix = np.dot(rightInsideMatrix, self.rightOutsideMatrix)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 计算出相机内参的逆矩阵</span></span><br><span class=\"line\">\t\tself.leftInsideMatrix_T_  = np.linalg.inv(self.leftInsideMatrix)</span><br><span class=\"line\">\t\tself.rightInsideMatrix_T_ = np.linalg.inv(self.rightInsideMatrix)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 计算出旋转矩阵的逆矩阵</span></span><br><span class=\"line\">\t\tself.left_R_T_  = np.linalg.inv(self.left_R)</span><br><span class=\"line\">\t\tself.right_R_T_ = np.linalg.inv(self.right_R)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPic</span>(<span class=\"params\">self,x_w,y_w,z_w,cam = <span class=\"string\">&#x27;l&#x27;</span></span>):</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># 通过世界坐标计算出图像中像素坐标</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># （x_w,y_w,z_w）坐标</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cam == <span class=\"string\">&#x27;l&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.leftCameraMatrix</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> cam == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.rightCameraMatrix</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tw_xyz  = np.array([x_w,y_w,z_w,<span class=\"number\">1</span>]).reshape(-<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tp_uv = np.dot(ma,w_xyz) / z_w</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(p_uv[<span class=\"number\">0</span>,<span class=\"number\">0</span>]),<span class=\"built_in\">int</span>(p_uv[<span class=\"number\">1</span>,<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countWord</span>(<span class=\"params\">self,u,v,z_w,cam = <span class=\"string\">&#x27;l&#x27;</span></span>):</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># 通过像素和深度计算世界坐标</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># 第u行v列像素</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cam == <span class=\"string\">&#x27;l&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.leftInsideMatrix_T_</span><br><span class=\"line\">\t\t\tR_T_ = self.left_R_T_</span><br><span class=\"line\">\t\t\tT = self.left_T</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> cam == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.rightInsideMatrix_T_</span><br><span class=\"line\">\t\t\tR_T_ = self.right_R_T_</span><br><span class=\"line\">\t\t\tT = self.right_T</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tp_xyz  = np.array([u,v,<span class=\"number\">1</span>]).reshape(-<span class=\"number\">1</span>,<span class=\"number\">1</span>) * z_w</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 公式计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tw_xyz = np.dot(R_T_,(np.dot(ma,p_xyz) - T))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> w_xyz[<span class=\"number\">0</span>,<span class=\"number\">0</span>],w_xyz[<span class=\"number\">1</span>,<span class=\"number\">0</span>],w_xyz[<span class=\"number\">2</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ ==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tc = CameraMatrix()</span><br><span class=\"line\">\tprint(c.countPic(<span class=\"number\">55</span>,<span class=\"number\">56</span>,<span class=\"number\">29</span>))</span><br><span class=\"line\">\tprint(c.countWord(<span class=\"number\">1227</span>, <span class=\"number\">1206</span>,<span class=\"number\">29</span>))</span><br></pre></td></tr></table></figure>\n","more":"<h2 id=\"坐标系简介\"><a href=\"#坐标系简介\" class=\"headerlink\" title=\"坐标系简介\"></a>坐标系简介</h2><p>注：本篇文章中四种坐标系都是<strong>左手坐标系</strong>，有些时候比如matlab所使用的就是右手坐标系，这个不会有太大的影响</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/axis.png\" alt=\"axis\"></p>\n<h3 id=\"世界坐标系\"><a href=\"#世界坐标系\" class=\"headerlink\" title=\"世界坐标系\"></a>世界坐标系</h3><ul>\n<li>庞大世界中的坐标系，可以表示万物的位置</li>\n<li>单位：m</li>\n<li>一般表述相机位置和实物位置</li>\n<li>Ow-XwYwZw来表示</li>\n<li>Ow是原点，双目系统中可以将任意一个摄像头的光心设置成原点，即世界坐标系和相机坐标系重合</li>\n</ul>\n<h3 id=\"相机坐标系\"><a href=\"#相机坐标系\" class=\"headerlink\" title=\"相机坐标系\"></a>相机坐标系</h3><ul>\n<li>存在于相机成像原理上，方便光的直线传播</li>\n<li>单位：m</li>\n<li>Oc-XcYcZc来表示</li>\n<li>Oc是原点，相机光心的位置，所有光都汇聚这一点</li>\n</ul>\n<h3 id=\"像素坐标系\"><a href=\"#像素坐标系\" class=\"headerlink\" title=\"像素坐标系\"></a>像素坐标系</h3><ul>\n<li>一张图片中的每个像素位置</li>\n<li>UV表示，但实际上有第三个坐标轴，用来表示颜色程度</li>\n<li>原点在左上角</li>\n</ul>\n<h3 id=\"图像坐标系\"><a href=\"#图像坐标系\" class=\"headerlink\" title=\"图像坐标系\"></a>图像坐标系</h3><ul>\n<li>O-XY来表示</li>\n<li>原点位于光轴上的一个点，用物理单位表示像素的位置</li>\n</ul>\n<h2 id=\"变换\"><a href=\"#变换\" class=\"headerlink\" title=\"变换\"></a>变换</h2><h3 id=\"世界坐标到相机坐标系\"><a href=\"#世界坐标到相机坐标系\" class=\"headerlink\" title=\"世界坐标到相机坐标系\"></a>世界坐标到相机坐标系</h3><h4 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h4><p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/cri.png\" alt=\"cri\"></p>\n<p>z轴是被围绕旋转的轴，z上的坐标保持不变。</p>\n<p>图片为o-x’y’z’旋转成o-xyz的过程</p>\n<script type=\"math/tex; mode=display\">\nx = x' cos(\\theta) - y' sin(\\theta) \\\\\ny = x' sin(\\theta) + y' cos(\\theta) \\\\\nz = z'</script><p>写成矩阵形式：</p>\n<script type=\"math/tex; mode=display\">\n绕Z轴旋转：\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   cos(\\theta) & -sin(\\theta) & 0\\\\\n   sin(\\theta) & cos(\\theta) & 0 \\\\\n   0 & 0 & 1 \n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} = R_1 \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix}</script><script type=\"math/tex; mode=display\">\n绕X轴旋转：\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   1 & 0 & 0\\\\\n   0 & cos(\\psi) & sin(\\psi)\\\\\n   0 & -sin(\\psi) & cos(\\psi) \n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} = R_2 \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix}</script><script type=\"math/tex; mode=display\">\n绕Y轴旋转：\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   cos(\\omega) & 0 & -sin(\\omega)\\\\\n   0 & 1 & 0 \\\\\n   sin(\\omega) & 0 & cos(\\omega) \n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} = R_3 \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix}</script><p>于是旋转矩阵可以表示为三个矩阵相乘：</p>\n<script type=\"math/tex; mode=display\">\nR = R_1 R_2 R_3</script><ul>\n<li>这里我们讨论一下旋转矩阵的一些性质：<ul>\n<li>三个旋转矩阵都是<strong>满秩</strong>（代数余子式可以算出旋转矩阵的行列式永远为1，也就是永远不会等于零）。</li>\n<li>没有旋转的时候就变成了单位矩阵。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h4><p>平移只需要在一个坐标基础上直接加上偏移量就可以实现平移：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   x \\\\\n   y \\\\\n   z\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} + \n\n  \\begin{bmatrix}\n   x_t \\\\\n   y_t \\\\\n   z_t\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   x' \\\\\n   y' \\\\\n   z'\n  \\end{bmatrix} + T</script><h4 id=\"综合到坐标系转换\"><a href=\"#综合到坐标系转换\" class=\"headerlink\" title=\"综合到坐标系转换\"></a>综合到坐标系转换</h4><p>由此可以推广到世界坐标系乘上一个旋转矩阵，转换成和相机坐标系相同方向的新坐标系，但需要一个平移T将坐标系平移过去：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   X_c \\\\\n   Y_c \\\\\n   Z_c\n  \\end{bmatrix} = R\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w\n  \\end{bmatrix} + T</script><p>但上面的公式比较麻烦，写成下面的方式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   X_c \\\\\n   Y_c \\\\\n   Z_c \\\\\n   1\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   R & T \\\\\n   \\vec{0} & 1 \\\\\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><ul>\n<li>R为旋转矩阵，（3*3）</li>\n<li>T为偏移向量，（3*1）</li>\n<li>零向量为（1*3）</li>\n</ul>\n<p>其实，我不喜欢这种形式，这种形式为了追求规整，放弃了一些比较好的特性，这个主要看个人习惯。我在接下来使用的时候为了计算方便，会再次拆开。</p>\n<h3 id=\"相机坐标系到图像坐标系\"><a href=\"#相机坐标系到图像坐标系\" class=\"headerlink\" title=\"相机坐标系到图像坐标系\"></a>相机坐标系到图像坐标系</h3><p>两种坐标系存在透视关系，是一种从3D转换到2D的转换，其中可以使用相似三角形进行比例计算。</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/cam2pic.png\" alt=\"cam2pic\"></p>\n<p>图中有两个相似三角形：</p>\n<script type=\"math/tex; mode=display\">\n\\triangle ABO_C \\sim \\triangle OCO_c \\\\\n\\triangle PBO_C \\sim \\triangle pCO_c</script><p>从两个相似三角形中可以找到一些长度的关系：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{AB}{oC} = \\frac{AO_c}{oO_c} = \\frac{BO_c}{CO_c} = \\frac{PB}{pC}</script><p>其中有些可以用其他表示：</p>\n<script type=\"math/tex; mode=display\">\nAB = X_c, oC = x\\\\\nAO_c = Z_c, oO_c = f \\\\\nPB = Y_c, pC = y</script><p>于是重新更改一下就变成了新的式子：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{X_c}{x} = \\frac{Y_c}{y} = \\frac{Z_c}{f}</script><p>我们的目的是想表示出图像坐标系，也就是用其他变量去表示(x,y)，这个时候就可以进行简单修改：</p>\n<script type=\"math/tex; mode=display\">\nx = f \\frac{X_c}{Z_c} \\\\\ny = f \\frac{Y_c}{Z_c}</script><p>接下来就转换成矩阵形式</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   x \\\\\n   y \\\\\n   1\n  \\end{bmatrix} = \n  \\begin{bmatrix}\n   f & 0 & 0 & 0 \\\\\n   0 & f & 0 & 0\\\\\n   0 & 0 & 1 & 0\n  \\end{bmatrix}\n  \\begin{bmatrix}\n   x_c \\\\\n   y_c \\\\\n   z_c \\\\\n   1\n  \\end{bmatrix}</script><h3 id=\"图像坐标系到像素坐标系\"><a href=\"#图像坐标系到像素坐标系\" class=\"headerlink\" title=\"图像坐标系到像素坐标系\"></a>图像坐标系到像素坐标系</h3><p>两个坐标系之间不存在旋转变换，只是原点坐标会有所差距而已</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/pic2uv.png\" alt=\"pic2uv\"></p>\n<p>这里假设每一个像素在u轴和v轴方向上的物理尺寸为dx和dy，可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nu = \\frac{x}{dx} + u_0 \\\\\nv = \\frac{y}{dy} + v_0 \\\\</script><p>写成矩阵形式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} = \n\n  \\begin{bmatrix}\n   \\frac{1}{dx} & 0 & u_0\\\\\n   0 & \\frac{1}{dy} & v_0\\\\\n   0 & 0 & 1\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   x \\\\\n   y \\\\\n   1\n  \\end{bmatrix}</script><h2 id=\"综合四种坐标系的相互变换\"><a href=\"#综合四种坐标系的相互变换\" class=\"headerlink\" title=\"综合四种坐标系的相互变换\"></a>综合四种坐标系的相互变换</h2><h3 id=\"整合\"><a href=\"#整合\" class=\"headerlink\" title=\"整合\"></a>整合</h3><p>之前讨论了每两个坐标系之间都有一套变换的方法，接下来就可以把这些方法全部综合在一起，生成一个比较复杂的公式，这个公式所表达的意思就是<strong>世界坐标</strong>和<strong>像素坐标</strong>的相互转化。</p>\n<p><img src=\"/2021/01/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%EF%BC%9A%E5%9B%9B%E7%A7%8D%E5%9D%90%E6%A0%87%E7%B3%BB/all.png\" alt=\"all\"></p>\n<p>用矩阵公式表达：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n  \\begin{bmatrix}\n   \\frac{1}{dx} & 0 & u_0\\\\\n   0 & \\frac{1}{dy} & v_0\\\\\n   0 & 0 & 1\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   f & 0 & 0 & 0 \\\\\n   0 & f & 0 & 0\\\\\n   0 & 0 & 1 & 0\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   R & T \\\\\n   \\vec{0} & 1 \\\\\n  \\end{bmatrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><p>接下来我们重新定义一组数据：</p>\n<script type=\"math/tex; mode=display\">\nf_x = \\frac{f}{dx} \\\\\nf_y = \\frac{f}{dy} \\\\</script><p>以上定义的两数据并没有太大的物理意义，仅仅是因为书写简单方便观看。既然有这种定义式了，那么矩阵中有些地方可以进行相乘，进一步简化：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       f_x & 0 & u_0 & 0 \\\\\n       0 & f_y & v_0 & 0\\\\\n       0 & 0 & 1 & 0\n      \\end{bmatrix}\n  } \\\\ 相机内参\n  \\end{matrix}\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       R & T \\\\\n       \\vec{0} & 1 \\\\\n      \\end{bmatrix}\n  } \\\\ 相机外参\n  \\end{matrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}\n\n \\tag{1}</script><p>公式中我分成了两部分，一个矩阵作为相机外参，另一个矩阵作为相机内参：</p>\n<ul>\n<li><p>相机内参：</p>\n<p>这个涉及到相机的构造，有些摄像头买来后，直接去测焦距像素大小可能会很麻烦，而且还不准确，所以这个矩阵一般不会用公式推导求出，这里建议采用张正友标定获取，在matlab中提供了这个程序，只要拍摄几张图片就可以直接获取相机内参。</p>\n<p><strong>注意</strong>：matlab中的世界坐标轴有点不太一样，使用的是世界右手坐标系，所以把y轴方向变成了反向</p>\n</li>\n<li><p>相机外参：</p>\n<p>这个矩阵是描述相机位置，例如在双目系统中，将一个摄像头光心设置成世界坐标系原点时，另一个摄像头可以根据原点进行一个变换，形成了一个新的坐标。</p>\n</li>\n</ul>\n<p>但我并不喜欢以上公式，整个公式是一步一步推理出来的，有几个地方反而有些冗余，我按照我自己的想法稍微修改了一点：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       f_x & 0 & u_0 \\\\\n       0 & f_y & v_0\\\\\n       0 & 0 & 1\n      \\end{bmatrix}\n  } \\\\ 相机内参\n  \\end{matrix}\n\n  \\begin{matrix} \\underbrace{\n      \\begin{bmatrix}\n       R & T \\\\\n\n      \\end{bmatrix}\n  } \\\\ 相机外参\n  \\end{matrix}\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}\n\n  \\tag{2}</script><p>我去点了相机内参中的最后一列和相机外参中最后一行，因为在整体计算中并没有什么作用，以上两个公式都可以使用，主要是怎么方便就用哪个公式去写代码。</p>\n<p>如果还想再简化一下，就可以写成这样：</p>\n<script type=\"math/tex; mode=display\">\nZ_c \\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n\n C\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}\n\n\\tag{3}</script><p>这里的C是一个3*4的矩阵，简化成这样，里面具体的元素已经没有太大的物理含义了，但这样书写有个好处，提前计算出C之后就可以直接使用C来计算整个算式。</p>\n<p>通过以上公式，很容易做到三维空间中的一个点在图像中的像素坐标，但反过来就，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。</p>\n<h3 id=\"像素和世界的相互转换\"><a href=\"#像素和世界的相互转换\" class=\"headerlink\" title=\"像素和世界的相互转换\"></a>像素和世界的相互转换</h3><ul>\n<li><strong><em>注</em></strong>：接下来的操作一定要知道深度（Zc或Zw）才能进行，虽然我们目的是求深度，但不影响我们使用下面的几个公式：</li>\n</ul>\n<h4 id=\"像素坐标转换成世界坐标\"><a href=\"#像素坐标转换成世界坐标\" class=\"headerlink\" title=\"像素坐标转换成世界坐标\"></a>像素坐标转换成世界坐标</h4><p>我把<strong>公式(3)</strong>改一下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} =\n  \\frac{1}{Z_c}\n    C\n   \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><p>仅仅是把Zc移到了右边，其实如果世界坐标和相机坐标系重合的话，Zc=Zw。</p>\n<p>整个函数的意思是，如果我们知道了世界坐标中具体的某一点坐标三个数值，就可以直接带入，求出u,v。</p>\n<h4 id=\"世界坐标转换成像素坐标\"><a href=\"#世界坐标转换成像素坐标\" class=\"headerlink\" title=\"世界坐标转换成像素坐标\"></a>世界坐标转换成像素坐标</h4><p>这时候我们不能去用<strong>公式(3)</strong>去修改，我们可以换个思路，使用<strong>公式(2)</strong>去修改：</p>\n<p>由于<strong>公式(2)</strong>中的相机内参是一个3*3的<strong>对角矩阵</strong>，而且很明显是一个可逆矩阵（对角中不会出现0），那么就可以求出这个矩阵的逆矩阵，写成以下形式：</p>\n<script type=\"math/tex; mode=display\">\nZ_c\n  \\begin{bmatrix}\n  f_x & 0 & u_0 \\\\\n  0 & f_y & v_0\\\\\n  0 & 0 & 1\n  \\end{bmatrix}^{-1}\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} \n\n\n    =\n \\begin{bmatrix}\n R & T \\\\\n\n\\end{bmatrix}\n\n\n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \\\\\n   1\n  \\end{bmatrix}</script><p>简单计算一下，等号左边最后计算的结果是一个3*1的矩阵，右边部分我们换个思路，回想一下外参矩阵的推演过程，我们可以写成这样：</p>\n<script type=\"math/tex; mode=display\">\nZ_c\n  \\begin{bmatrix}\n  f_x & 0 & u_0 \\\\\n  0 & f_y & v_0\\\\\n  0 & 0 & 1\n  \\end{bmatrix}^{-1}\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix} \n   =\n R \n  \\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \n\n  \\end{bmatrix}\n   + T</script><p>那么所有矩阵往左边移动：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n   X_w \\\\\n   Y_w \\\\\n   Z_w \n  \\end{bmatrix}\n  =R^{-1}\n\\Bigg(\nZ_c\n  \\begin{bmatrix}\n  f_x & 0 & u_0 \\\\\n  0 & f_y & v_0\\\\\n  0 & 0 & 1\n  \\end{bmatrix}^{-1}\n\\begin{bmatrix}\n   u \\\\\n   v \\\\\n   1\n  \\end{bmatrix}   - T \\Bigg)</script><p>虽然在双目系统中，我们做不到提前给出Zc或Zw，所以以上公式进行参考即可，在一定程度上还是比较方便。</p>\n<h2 id=\"程序\"><a href=\"#程序\" class=\"headerlink\" title=\"程序\"></a>程序</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> scipy.io <span class=\"keyword\">as</span> sio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CameraMatrix</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, path = <span class=\"string\">&#x27;camera_data.mat&#x27;</span></span>):</span></span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"comment\"># 从camera_data.mat文件中导入数据</span></span><br><span class=\"line\">\t\tdata=sio.loadmat(path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.leftInsideMatrix = data[<span class=\"string\">&#x27;leftInsideMatrix&#x27;</span>]</span><br><span class=\"line\">\t\tself.rightInsideMatrix = data[<span class=\"string\">&#x27;rightInsideMatrix&#x27;</span>]</span><br><span class=\"line\">\t\tself.leftOutsideMatrix = data[<span class=\"string\">&#x27;leftOutsideMatrix&#x27;</span>]</span><br><span class=\"line\">\t\tself.rightOutsideMatrix = data[<span class=\"string\">&#x27;rightOutsideMatrix&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.__dataInit()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__dataInit</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 分解出旋转矩阵</span></span><br><span class=\"line\">\t\tself.left_R  = self.leftOutsideMatrix[:<span class=\"number\">3</span>,:<span class=\"number\">3</span>]</span><br><span class=\"line\">\t\tself.right_R = self.rightOutsideMatrix[:<span class=\"number\">3</span>,:<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 分解出偏移向量</span></span><br><span class=\"line\">\t\tself.left_T  = self.leftOutsideMatrix[:<span class=\"number\">3</span>,-<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\tself.right_T = self.rightOutsideMatrix[:<span class=\"number\">3</span>,-<span class=\"number\">1</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\">\t\to = np.array([<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]).reshape(-<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 制作出规整的相机内参</span></span><br><span class=\"line\">\t\tleftInsideMatrix  = np.concatenate((self.leftInsideMatrix,o),axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\trightInsideMatrix = np.concatenate((self.rightInsideMatrix,o),axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 计算出完整相机参数</span></span><br><span class=\"line\">\t\tself.leftCameraMatrix = np.dot(leftInsideMatrix, self.leftOutsideMatrix)</span><br><span class=\"line\">\t\tself.rightCameraMatrix = np.dot(rightInsideMatrix, self.rightOutsideMatrix)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 计算出相机内参的逆矩阵</span></span><br><span class=\"line\">\t\tself.leftInsideMatrix_T_  = np.linalg.inv(self.leftInsideMatrix)</span><br><span class=\"line\">\t\tself.rightInsideMatrix_T_ = np.linalg.inv(self.rightInsideMatrix)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 计算出旋转矩阵的逆矩阵</span></span><br><span class=\"line\">\t\tself.left_R_T_  = np.linalg.inv(self.left_R)</span><br><span class=\"line\">\t\tself.right_R_T_ = np.linalg.inv(self.right_R)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countPic</span>(<span class=\"params\">self,x_w,y_w,z_w,cam = <span class=\"string\">&#x27;l&#x27;</span></span>):</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># 通过世界坐标计算出图像中像素坐标</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># （x_w,y_w,z_w）坐标</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cam == <span class=\"string\">&#x27;l&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.leftCameraMatrix</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> cam == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.rightCameraMatrix</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tw_xyz  = np.array([x_w,y_w,z_w,<span class=\"number\">1</span>]).reshape(-<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tp_uv = np.dot(ma,w_xyz) / z_w</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(p_uv[<span class=\"number\">0</span>,<span class=\"number\">0</span>]),<span class=\"built_in\">int</span>(p_uv[<span class=\"number\">1</span>,<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countWord</span>(<span class=\"params\">self,u,v,z_w,cam = <span class=\"string\">&#x27;l&#x27;</span></span>):</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># 通过像素和深度计算世界坐标</span></span><br><span class=\"line\">\t\t<span class=\"comment\"># 第u行v列像素</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> cam == <span class=\"string\">&#x27;l&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.leftInsideMatrix_T_</span><br><span class=\"line\">\t\t\tR_T_ = self.left_R_T_</span><br><span class=\"line\">\t\t\tT = self.left_T</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> cam == <span class=\"string\">&#x27;r&#x27;</span>:</span><br><span class=\"line\">\t\t\tma = self.rightInsideMatrix_T_</span><br><span class=\"line\">\t\t\tR_T_ = self.right_R_T_</span><br><span class=\"line\">\t\t\tT = self.right_T</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tp_xyz  = np.array([u,v,<span class=\"number\">1</span>]).reshape(-<span class=\"number\">1</span>,<span class=\"number\">1</span>) * z_w</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 公式计算</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tw_xyz = np.dot(R_T_,(np.dot(ma,p_xyz) - T))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> w_xyz[<span class=\"number\">0</span>,<span class=\"number\">0</span>],w_xyz[<span class=\"number\">1</span>,<span class=\"number\">0</span>],w_xyz[<span class=\"number\">2</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ ==<span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\tc = CameraMatrix()</span><br><span class=\"line\">\tprint(c.countPic(<span class=\"number\">55</span>,<span class=\"number\">56</span>,<span class=\"number\">29</span>))</span><br><span class=\"line\">\tprint(c.countWord(<span class=\"number\">1227</span>, <span class=\"number\">1206</span>,<span class=\"number\">29</span>))</span><br></pre></td></tr></table></figure>","categories":[{"name":"机器视觉","path":"api/categories/机器视觉.json"}],"tags":[{"name":"双目立体成像","path":"api/tags/双目立体成像.json"},{"name":"原理","path":"api/tags/原理.json"}]}