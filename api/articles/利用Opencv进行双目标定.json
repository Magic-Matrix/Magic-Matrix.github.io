{"title":"利用Opencv进行双目标定","slug":"利用Opencv进行双目标定","date":"2021-09-28T07:36:08.000Z","updated":"2021-09-28T09:20:15.771Z","comments":true,"path":"api/articles/利用Opencv进行双目标定.json","excerpt":"前段时间进行了摄像头标定，我使用过matlab直接标定，效果感觉还可以。那么这次纯粹是使用Opencv来进行一次标定。","covers":["/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/board.jpeg","/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/image.jpg","/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/old_image.jpg","/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/new_image.jpg"],"content":"<p>前段时间进行了摄像头标定，我使用过matlab直接标定，效果感觉还可以。那么这次纯粹是使用Opencv来进行一次标定。</p>\n<a id=\"more\"></a>\n<h2 id=\"准备标定板\"><a href=\"#准备标定板\" class=\"headerlink\" title=\"准备标定板\"></a>准备标定板</h2><p>标定板是必不可少的，这里我说明一下，建议使用长宽不等的标定板，这样可以避免出现错误的姿态误差。比如我下面准备的图片。</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/board.jpeg\" alt=\"board\"></p>\n<p>我是直接打印出来，其实并不建议直接打印，因为我打印出来后发现整张纸有点潮，晾干后不太平整，所以并不太建议直接打印。</p>\n<h2 id=\"标定程序\"><a href=\"#标定程序\" class=\"headerlink\" title=\"标定程序\"></a>标定程序</h2><p>先说一下步骤：</p>\n<ul>\n<li>定位出图片中所有的角点</li>\n<li>利用所有的角点去进行单目标定</li>\n<li>利用所有的角点去进行双目标定</li>\n</ul>\n<h3 id=\"定位角点\"><a href=\"#定位角点\" class=\"headerlink\" title=\"定位角点\"></a>定位角点</h3><p>当然，在找点前需要把图片导进来，导进来是一个 <code>numpy</code> 的矩阵，形状为<code>(h, w, 3)</code>。</p>\n<p>接下来我就直接定义了个函数，用来专门定位。</p>\n<p>这个函数简单介绍一下，有两个参数：</p>\n<ul>\n<li><code>image</code>是图片的矩阵</li>\n<li><code>size</code>是标定板的角点的尺寸，上面的那张标定图就是<code>(11, 8)</code></li>\n</ul>\n<p>返回值就只有两种可能，如果能找到就直接返回点，找不到就返回<code>None</code>。</p>\n<p>程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cornerFind</span>(<span class=\"params\">image, size</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    角点查找</span></span><br><span class=\"line\"><span class=\"string\">    :param image: 图片</span></span><br><span class=\"line\"><span class=\"string\">    :param size: 角点个数（横向个数，纵向个数）</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 寻找</span></span><br><span class=\"line\">    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class=\"number\">30</span>, <span class=\"number\">0.001</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 灰度化</span></span><br><span class=\"line\">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 定位角点</span></span><br><span class=\"line\">    success, corners = cv2.findChessboardCorners(gray, size, <span class=\"literal\">None</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> success:</span><br><span class=\"line\">        <span class=\"comment\"># 成功定位到的话</span></span><br><span class=\"line\">        <span class=\"comment\"># 再次使用亚像素定位角点，这样精度更高</span></span><br><span class=\"line\">        output = cv2.cornerSubPix(gray, corners, (<span class=\"number\">11</span>, <span class=\"number\">11</span>), (-<span class=\"number\">1</span>, -<span class=\"number\">1</span>), criteria)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>单张图片定位角点的程序有了，那么就直接使用。</p>\n<p>接下来就是把每次的结果直接放进列表里：</p>\n<ul>\n<li>定义<code>obj_points</code>列表，专门放标定板的坐标</li>\n<li>定义<code>left_img_points</code>列表，专门放左相机拍摄的角点</li>\n<li>定义<code>right_img_points</code>列表，专门放右相机拍摄的角点</li>\n</ul>\n<p>那么，完整的程序就是如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 标定板的尺寸</span></span><br><span class=\"line\">board = (<span class=\"number\">11</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"comment\"># 每个块的宽度</span></span><br><span class=\"line\">size = <span class=\"number\">19.2</span></span><br><span class=\"line\"></span><br><span class=\"line\">bw, bh = board</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标定板的坐标</span></span><br><span class=\"line\">objp = np.zeros((bw * bh, <span class=\"number\">3</span>), np.float32)</span><br><span class=\"line\">objp[:, :<span class=\"number\">2</span>] = np.mgrid[<span class=\"number\">0</span>:bw, <span class=\"number\">0</span>:bh].T.reshape(-<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">objp *= size</span><br><span class=\"line\"></span><br><span class=\"line\">obj_points = []  <span class=\"comment\"># 存储标定板的坐标</span></span><br><span class=\"line\">left_img_points = []  <span class=\"comment\"># 存储图片上的</span></span><br><span class=\"line\">right_img_points = []  <span class=\"comment\"># 存储图片上的</span></span><br><span class=\"line\"></span><br><span class=\"line\">image_size = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 利用循环来读取图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> left_path, right_path <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(left_image_list, right_image_list):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 读取图片（左右相机图片）</span></span><br><span class=\"line\">    left_image = cv2.imread(left_path)</span><br><span class=\"line\">    right_image = cv2.imread(right_path)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取图片尺寸</span></span><br><span class=\"line\">    image_size = left_image.shape[<span class=\"number\">1</span>::-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取角点</span></span><br><span class=\"line\">    left_corners = cornerFind(left_image, board)</span><br><span class=\"line\">    right_corners = cornerFind(right_image, board)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left_corners <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>) <span class=\"keyword\">and</span> (right_corners <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 添加一个标定板坐标</span></span><br><span class=\"line\">        obj_points.append(objp)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 添加一个图片坐标</span></span><br><span class=\"line\">        left_img_points.append(left_corners)</span><br><span class=\"line\">        right_img_points.append(right_corners)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 画出来</span></span><br><span class=\"line\">        cv2.drawChessboardCorners(left_image, board, left_corners, <span class=\"literal\">True</span>)</span><br><span class=\"line\">        cv2.drawChessboardCorners(right_image, board, right_corners, <span class=\"literal\">True</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 画出第一个点</span></span><br><span class=\"line\">        cv2.circle(left_image, left_corners[<span class=\"number\">0</span>, <span class=\"number\">0</span>].astype(<span class=\"built_in\">int</span>), <span class=\"number\">10</span>, (<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">        cv2.circle(right_image, right_corners[<span class=\"number\">0</span>, <span class=\"number\">0</span>].astype(<span class=\"built_in\">int</span>), <span class=\"number\">10</span>, (<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 显示出来</span></span><br><span class=\"line\">        <span class=\"comment\"># cv2.imshow(&quot;left&quot;, left_image)</span></span><br><span class=\"line\">        <span class=\"comment\"># cv2.imshow(&quot;right&quot;, right_image)</span></span><br><span class=\"line\">        <span class=\"comment\"># print(left_corners)</span></span><br><span class=\"line\">        <span class=\"comment\"># cv2.waitKey(0)</span></span><br></pre></td></tr></table></figure>\n<p>这里我来说一下<code>size</code>这个变量，Opencv的量纲是毫米，<code>size</code>就是单个方框的尺寸，我打印出来之后测量了一下就是 19.2 mm，所以<code>objp *= size</code>的作用就是，将标定板做成实际坐标。</p>\n<p>看一下效果吧：</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/image.jpg\" alt=\"image\"></p>\n<h3 id=\"单目标定\"><a href=\"#单目标定\" class=\"headerlink\" title=\"单目标定\"></a>单目标定</h3><p>单目就直接使用<code>cv2.calibrateCamera()</code>就可以直接标定。</p>\n<p>会返回出五个结果，分别是：精度、内参矩阵、畸变参数、旋转矩阵、平移向量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 左相机标定</span></span><br><span class=\"line\">_, l_mtx, l_dist, _, _ = cv2.calibrateCamera(</span><br><span class=\"line\">    obj_points, left_img_points, image_size, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># 右相机标定</span></span><br><span class=\"line\">_, r_mtx, r_dist, _, _  = cv2.calibrateCamera(</span><br><span class=\"line\">    obj_points, right_img_points, image_size, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>在接下来的使用中只会使用到内参矩阵和畸变参数，所以，不会直接使用其他的返回值。</p>\n<h3 id=\"双目标定\"><a href=\"#双目标定\" class=\"headerlink\" title=\"双目标定\"></a>双目标定</h3><p>双目就直接使用<code>cv2.stereoCalibrate()</code>函数。</p>\n<p>返回值是：精度、左相机内参矩阵、左相机畸变参数、右相机内参矩阵、右相机畸变参数、旋转矩阵、平移向量、本征矩阵、基本矩阵。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 双目相机标定</span></span><br><span class=\"line\">ret, l_mtx, l_dist, r_mtx, r_dist, R, T, E, F = cv2.stereoCalibrate(</span><br><span class=\"line\">    obj_points,                             <span class=\"comment\"># 位置信息</span></span><br><span class=\"line\">    left_img_points, right_img_points,      <span class=\"comment\"># 左右图片的点</span></span><br><span class=\"line\">    l_mtx, l_dist,                 <span class=\"comment\"># 左内参矩阵、畸变参数</span></span><br><span class=\"line\">    r_mtx, r_dist,                 <span class=\"comment\"># 右内参矩阵、畸变参数</span></span><br><span class=\"line\">    image_size)</span><br></pre></td></tr></table></figure>\n<p>说明一下，旋转矩阵和平移向量是第二个相机（右相机）相对于第一个相机而言（左相机）。</p>\n<h3 id=\"参数保存\"><a href=\"#参数保存\" class=\"headerlink\" title=\"参数保存\"></a>参数保存</h3><p>随便使用一个方法把这些参数保存下来，这样就可以下此就直接使用了。</p>\n<p>可以保存成json格式，方便自己私自打开查看。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>以上就是标定的过程，具体的使用还是如下所示。</p>\n<h3 id=\"去除畸变和图像校正\"><a href=\"#去除畸变和图像校正\" class=\"headerlink\" title=\"去除畸变和图像校正\"></a>去除畸变和图像校正</h3><p>标定完了之后，就可以直接使用了，主要是分为两步：</p>\n<ul>\n<li>去除畸变：目的是消除图片的切向畸变和径向畸变</li>\n<li>图像校正：将对应位置进行调平</li>\n</ul>\n<p>这里我就直接使用<code>cv2.stereoRectify()</code>函数和<code>cv2.initUndistortRectifyMap()</code>函数，我再这里直接封装成了一个类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectifyDistort</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, size: <span class=\"built_in\">tuple</span>, datas: <span class=\"built_in\">dict</span></span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 计算出立体矫正所需要的映射矩阵</span></span><br><span class=\"line\">        R1, R2, P1, P2, Q, validPixROI1, validPixROI2 = cv2.stereoRectify(</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;leftCameraMatrix&quot;</span>], datas[<span class=\"string\">&quot;leftDistCoeffs&quot;</span>],</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;rightCameraMatrix&quot;</span>], datas[<span class=\"string\">&quot;rightDistCoeffs&quot;</span>],</span><br><span class=\"line\">            size, datas[<span class=\"string\">&quot;R&quot;</span>], datas[<span class=\"string\">&quot;T&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        self.Q = Q</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 左-重映射矩阵</span></span><br><span class=\"line\">        self.left_map = cv2.initUndistortRectifyMap(</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;leftCameraMatrix&quot;</span>],</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;leftDistCoeffs&quot;</span>],</span><br><span class=\"line\">            R1, P1, size, cv2.INTER_NEAREST)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 右-重映射矩阵</span></span><br><span class=\"line\">        self.right_map = cv2.initUndistortRectifyMap(</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;rightCameraMatrix&quot;</span>],</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;rightDistCoeffs&quot;</span>],</span><br><span class=\"line\">            R2, P2, size, cv2.INTER_NEAREST)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span>(<span class=\"params\">self, image: np.ndarray, camera: <span class=\"built_in\">str</span></span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        校正图</span></span><br><span class=\"line\"><span class=\"string\">        :param image:</span></span><br><span class=\"line\"><span class=\"string\">        :param camera: 摄像头区分</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> camera == <span class=\"string\">&quot;left&quot;</span>:</span><br><span class=\"line\">            map1, map2 = self.left_map</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> camera == <span class=\"string\">&quot;right&quot;</span>:</span><br><span class=\"line\">            map1, map2 = self.right_map</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError</span><br><span class=\"line\"></span><br><span class=\"line\">        new_image = cv2.remap(image, map1, map2, cv2.INTER_LINEAR)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_image</span><br></pre></td></tr></table></figure>\n<p>直接看图片效果。</p>\n<p>未处理图片：</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/old_image.jpg\" alt=\"old_image\"></p>\n<p>处理图片：</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/new_image.jpg\" alt=\"new_image\"></p>\n<h3 id=\"Q矩阵的使用\"><a href=\"#Q矩阵的使用\" class=\"headerlink\" title=\"Q矩阵的使用\"></a>Q矩阵的使用</h3><p>在上面的程序中，还会得到一个Q矩阵，这是一个关键的矩阵，可以利用此矩阵直接将世界坐标计算出来。</p>\n<p>公式为：</p>\n<script type=\"math/tex; mode=display\">\nQ \\left[ \\begin{matrix} x \\\\ y \\\\d \\\\ 1 \\end{matrix} \\right] = \\left[ \\begin{matrix} X \\\\ Y \\\\ Z \\\\ W \\end{matrix} \\right]</script><p>直接使用Q矩阵乘上一个向量就可以直接得出，世界坐标。</p>\n<p>这里说明两点：</p>\n<ul>\n<li>x、y、d的单位是像素</li>\n<li>X/W，Y/W，Z/W，才是最终的世界坐标，单位是毫米</li>\n<li>d是视差值，左像素和右像素的之差</li>\n</ul>\n","more":"<h2 id=\"准备标定板\"><a href=\"#准备标定板\" class=\"headerlink\" title=\"准备标定板\"></a>准备标定板</h2><p>标定板是必不可少的，这里我说明一下，建议使用长宽不等的标定板，这样可以避免出现错误的姿态误差。比如我下面准备的图片。</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/board.jpeg\" alt=\"board\"></p>\n<p>我是直接打印出来，其实并不建议直接打印，因为我打印出来后发现整张纸有点潮，晾干后不太平整，所以并不太建议直接打印。</p>\n<h2 id=\"标定程序\"><a href=\"#标定程序\" class=\"headerlink\" title=\"标定程序\"></a>标定程序</h2><p>先说一下步骤：</p>\n<ul>\n<li>定位出图片中所有的角点</li>\n<li>利用所有的角点去进行单目标定</li>\n<li>利用所有的角点去进行双目标定</li>\n</ul>\n<h3 id=\"定位角点\"><a href=\"#定位角点\" class=\"headerlink\" title=\"定位角点\"></a>定位角点</h3><p>当然，在找点前需要把图片导进来，导进来是一个 <code>numpy</code> 的矩阵，形状为<code>(h, w, 3)</code>。</p>\n<p>接下来我就直接定义了个函数，用来专门定位。</p>\n<p>这个函数简单介绍一下，有两个参数：</p>\n<ul>\n<li><code>image</code>是图片的矩阵</li>\n<li><code>size</code>是标定板的角点的尺寸，上面的那张标定图就是<code>(11, 8)</code></li>\n</ul>\n<p>返回值就只有两种可能，如果能找到就直接返回点，找不到就返回<code>None</code>。</p>\n<p>程序如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cornerFind</span>(<span class=\"params\">image, size</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    角点查找</span></span><br><span class=\"line\"><span class=\"string\">    :param image: 图片</span></span><br><span class=\"line\"><span class=\"string\">    :param size: 角点个数（横向个数，纵向个数）</span></span><br><span class=\"line\"><span class=\"string\">    :return:</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 寻找</span></span><br><span class=\"line\">    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class=\"number\">30</span>, <span class=\"number\">0.001</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 灰度化</span></span><br><span class=\"line\">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 定位角点</span></span><br><span class=\"line\">    success, corners = cv2.findChessboardCorners(gray, size, <span class=\"literal\">None</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> success:</span><br><span class=\"line\">        <span class=\"comment\"># 成功定位到的话</span></span><br><span class=\"line\">        <span class=\"comment\"># 再次使用亚像素定位角点，这样精度更高</span></span><br><span class=\"line\">        output = cv2.cornerSubPix(gray, corners, (<span class=\"number\">11</span>, <span class=\"number\">11</span>), (-<span class=\"number\">1</span>, -<span class=\"number\">1</span>), criteria)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>单张图片定位角点的程序有了，那么就直接使用。</p>\n<p>接下来就是把每次的结果直接放进列表里：</p>\n<ul>\n<li>定义<code>obj_points</code>列表，专门放标定板的坐标</li>\n<li>定义<code>left_img_points</code>列表，专门放左相机拍摄的角点</li>\n<li>定义<code>right_img_points</code>列表，专门放右相机拍摄的角点</li>\n</ul>\n<p>那么，完整的程序就是如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 标定板的尺寸</span></span><br><span class=\"line\">board = (<span class=\"number\">11</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"comment\"># 每个块的宽度</span></span><br><span class=\"line\">size = <span class=\"number\">19.2</span></span><br><span class=\"line\"></span><br><span class=\"line\">bw, bh = board</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 标定板的坐标</span></span><br><span class=\"line\">objp = np.zeros((bw * bh, <span class=\"number\">3</span>), np.float32)</span><br><span class=\"line\">objp[:, :<span class=\"number\">2</span>] = np.mgrid[<span class=\"number\">0</span>:bw, <span class=\"number\">0</span>:bh].T.reshape(-<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">objp *= size</span><br><span class=\"line\"></span><br><span class=\"line\">obj_points = []  <span class=\"comment\"># 存储标定板的坐标</span></span><br><span class=\"line\">left_img_points = []  <span class=\"comment\"># 存储图片上的</span></span><br><span class=\"line\">right_img_points = []  <span class=\"comment\"># 存储图片上的</span></span><br><span class=\"line\"></span><br><span class=\"line\">image_size = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 利用循环来读取图片</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> left_path, right_path <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(left_image_list, right_image_list):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 读取图片（左右相机图片）</span></span><br><span class=\"line\">    left_image = cv2.imread(left_path)</span><br><span class=\"line\">    right_image = cv2.imread(right_path)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取图片尺寸</span></span><br><span class=\"line\">    image_size = left_image.shape[<span class=\"number\">1</span>::-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取角点</span></span><br><span class=\"line\">    left_corners = cornerFind(left_image, board)</span><br><span class=\"line\">    right_corners = cornerFind(right_image, board)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left_corners <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>) <span class=\"keyword\">and</span> (right_corners <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 添加一个标定板坐标</span></span><br><span class=\"line\">        obj_points.append(objp)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 添加一个图片坐标</span></span><br><span class=\"line\">        left_img_points.append(left_corners)</span><br><span class=\"line\">        right_img_points.append(right_corners)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 画出来</span></span><br><span class=\"line\">        cv2.drawChessboardCorners(left_image, board, left_corners, <span class=\"literal\">True</span>)</span><br><span class=\"line\">        cv2.drawChessboardCorners(right_image, board, right_corners, <span class=\"literal\">True</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># 画出第一个点</span></span><br><span class=\"line\">        cv2.circle(left_image, left_corners[<span class=\"number\">0</span>, <span class=\"number\">0</span>].astype(<span class=\"built_in\">int</span>), <span class=\"number\">10</span>, (<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">        cv2.circle(right_image, right_corners[<span class=\"number\">0</span>, <span class=\"number\">0</span>].astype(<span class=\"built_in\">int</span>), <span class=\"number\">10</span>, (<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 显示出来</span></span><br><span class=\"line\">        <span class=\"comment\"># cv2.imshow(&quot;left&quot;, left_image)</span></span><br><span class=\"line\">        <span class=\"comment\"># cv2.imshow(&quot;right&quot;, right_image)</span></span><br><span class=\"line\">        <span class=\"comment\"># print(left_corners)</span></span><br><span class=\"line\">        <span class=\"comment\"># cv2.waitKey(0)</span></span><br></pre></td></tr></table></figure>\n<p>这里我来说一下<code>size</code>这个变量，Opencv的量纲是毫米，<code>size</code>就是单个方框的尺寸，我打印出来之后测量了一下就是 19.2 mm，所以<code>objp *= size</code>的作用就是，将标定板做成实际坐标。</p>\n<p>看一下效果吧：</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/image.jpg\" alt=\"image\"></p>\n<h3 id=\"单目标定\"><a href=\"#单目标定\" class=\"headerlink\" title=\"单目标定\"></a>单目标定</h3><p>单目就直接使用<code>cv2.calibrateCamera()</code>就可以直接标定。</p>\n<p>会返回出五个结果，分别是：精度、内参矩阵、畸变参数、旋转矩阵、平移向量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 左相机标定</span></span><br><span class=\"line\">_, l_mtx, l_dist, _, _ = cv2.calibrateCamera(</span><br><span class=\"line\">    obj_points, left_img_points, image_size, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># 右相机标定</span></span><br><span class=\"line\">_, r_mtx, r_dist, _, _  = cv2.calibrateCamera(</span><br><span class=\"line\">    obj_points, right_img_points, image_size, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>在接下来的使用中只会使用到内参矩阵和畸变参数，所以，不会直接使用其他的返回值。</p>\n<h3 id=\"双目标定\"><a href=\"#双目标定\" class=\"headerlink\" title=\"双目标定\"></a>双目标定</h3><p>双目就直接使用<code>cv2.stereoCalibrate()</code>函数。</p>\n<p>返回值是：精度、左相机内参矩阵、左相机畸变参数、右相机内参矩阵、右相机畸变参数、旋转矩阵、平移向量、本征矩阵、基本矩阵。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 双目相机标定</span></span><br><span class=\"line\">ret, l_mtx, l_dist, r_mtx, r_dist, R, T, E, F = cv2.stereoCalibrate(</span><br><span class=\"line\">    obj_points,                             <span class=\"comment\"># 位置信息</span></span><br><span class=\"line\">    left_img_points, right_img_points,      <span class=\"comment\"># 左右图片的点</span></span><br><span class=\"line\">    l_mtx, l_dist,                 <span class=\"comment\"># 左内参矩阵、畸变参数</span></span><br><span class=\"line\">    r_mtx, r_dist,                 <span class=\"comment\"># 右内参矩阵、畸变参数</span></span><br><span class=\"line\">    image_size)</span><br></pre></td></tr></table></figure>\n<p>说明一下，旋转矩阵和平移向量是第二个相机（右相机）相对于第一个相机而言（左相机）。</p>\n<h3 id=\"参数保存\"><a href=\"#参数保存\" class=\"headerlink\" title=\"参数保存\"></a>参数保存</h3><p>随便使用一个方法把这些参数保存下来，这样就可以下此就直接使用了。</p>\n<p>可以保存成json格式，方便自己私自打开查看。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>以上就是标定的过程，具体的使用还是如下所示。</p>\n<h3 id=\"去除畸变和图像校正\"><a href=\"#去除畸变和图像校正\" class=\"headerlink\" title=\"去除畸变和图像校正\"></a>去除畸变和图像校正</h3><p>标定完了之后，就可以直接使用了，主要是分为两步：</p>\n<ul>\n<li>去除畸变：目的是消除图片的切向畸变和径向畸变</li>\n<li>图像校正：将对应位置进行调平</li>\n</ul>\n<p>这里我就直接使用<code>cv2.stereoRectify()</code>函数和<code>cv2.initUndistortRectifyMap()</code>函数，我再这里直接封装成了一个类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectifyDistort</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, size: <span class=\"built_in\">tuple</span>, datas: <span class=\"built_in\">dict</span></span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 计算出立体矫正所需要的映射矩阵</span></span><br><span class=\"line\">        R1, R2, P1, P2, Q, validPixROI1, validPixROI2 = cv2.stereoRectify(</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;leftCameraMatrix&quot;</span>], datas[<span class=\"string\">&quot;leftDistCoeffs&quot;</span>],</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;rightCameraMatrix&quot;</span>], datas[<span class=\"string\">&quot;rightDistCoeffs&quot;</span>],</span><br><span class=\"line\">            size, datas[<span class=\"string\">&quot;R&quot;</span>], datas[<span class=\"string\">&quot;T&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        self.Q = Q</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 左-重映射矩阵</span></span><br><span class=\"line\">        self.left_map = cv2.initUndistortRectifyMap(</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;leftCameraMatrix&quot;</span>],</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;leftDistCoeffs&quot;</span>],</span><br><span class=\"line\">            R1, P1, size, cv2.INTER_NEAREST)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 右-重映射矩阵</span></span><br><span class=\"line\">        self.right_map = cv2.initUndistortRectifyMap(</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;rightCameraMatrix&quot;</span>],</span><br><span class=\"line\">            datas[<span class=\"string\">&quot;rightDistCoeffs&quot;</span>],</span><br><span class=\"line\">            R2, P2, size, cv2.INTER_NEAREST)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span>(<span class=\"params\">self, image: np.ndarray, camera: <span class=\"built_in\">str</span></span>):</span></span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        校正图</span></span><br><span class=\"line\"><span class=\"string\">        :param image:</span></span><br><span class=\"line\"><span class=\"string\">        :param camera: 摄像头区分</span></span><br><span class=\"line\"><span class=\"string\">        :return:</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> camera == <span class=\"string\">&quot;left&quot;</span>:</span><br><span class=\"line\">            map1, map2 = self.left_map</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> camera == <span class=\"string\">&quot;right&quot;</span>:</span><br><span class=\"line\">            map1, map2 = self.right_map</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError</span><br><span class=\"line\"></span><br><span class=\"line\">        new_image = cv2.remap(image, map1, map2, cv2.INTER_LINEAR)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_image</span><br></pre></td></tr></table></figure>\n<p>直接看图片效果。</p>\n<p>未处理图片：</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/old_image.jpg\" alt=\"old_image\"></p>\n<p>处理图片：</p>\n<p><img src=\"/2021/09/%E5%88%A9%E7%94%A8Opencv%E8%BF%9B%E8%A1%8C%E5%8F%8C%E7%9B%AE%E6%A0%87%E5%AE%9A/new_image.jpg\" alt=\"new_image\"></p>\n<h3 id=\"Q矩阵的使用\"><a href=\"#Q矩阵的使用\" class=\"headerlink\" title=\"Q矩阵的使用\"></a>Q矩阵的使用</h3><p>在上面的程序中，还会得到一个Q矩阵，这是一个关键的矩阵，可以利用此矩阵直接将世界坐标计算出来。</p>\n<p>公式为：</p>\n<script type=\"math/tex; mode=display\">\nQ \\left[ \\begin{matrix} x \\\\ y \\\\d \\\\ 1 \\end{matrix} \\right] = \\left[ \\begin{matrix} X \\\\ Y \\\\ Z \\\\ W \\end{matrix} \\right]</script><p>直接使用Q矩阵乘上一个向量就可以直接得出，世界坐标。</p>\n<p>这里说明两点：</p>\n<ul>\n<li>x、y、d的单位是像素</li>\n<li>X/W，Y/W，Z/W，才是最终的世界坐标，单位是毫米</li>\n<li>d是视差值，左像素和右像素的之差</li>\n</ul>","categories":[{"name":"机器视觉","path":"api/categories/机器视觉.json"}],"tags":[{"name":"双目立体成像","path":"api/tags/双目立体成像.json"},{"name":"原理","path":"api/tags/原理.json"}]}